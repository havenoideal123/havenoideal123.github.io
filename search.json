[{"title":"helloworld.md","url":"/2025/10/30/helloworld-md/","content":""},{"title":"小型内核加载程序.md","url":"/2025/11/06/%E5%B0%8F%E5%9E%8B%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F-md/","content":"李忠老师书中15章的内容，浅读时觉得十分困难乏味，如今按照先看懂代码再看书理解思路的方式，将整个代码进行了手敲，感受颇多，也体会到了李忠老师深厚的汇编功底。\n整个代码分为三个部分\n\n主引导代码：负责设置GDT和加载内核代码\n内核代码：负责用户程序的加载\n用户程序：读取一个扇区中的内容并显示\n\n再次建议大家自己手敲一遍代码，理解程度绝非是直接看书能够比拟的。许多难以理解的代码李忠老师均已作出解答。\n主引导区代码\n;主引导分区的代码，主要用于加载内核core_base_address equ 0x00040000 ;定义常数，内核加载的起始位置core_start_sector equ 0x00000001 ;开始的逻辑扇区，用工具先把内核写在1扇区;常规设置套路;初始化堆栈mov ax,csmov ss,axmov sp,0x7c00;计算GDT逻辑地址mov eax,[cs:pgdt+ 0x7c00 + 0x02] ;GDT的物理地址xor edx,edx ;清零mov ebx,16div ebx ;商在eax里，余数在edxmov ds,eax ;指向GDTmov ebx,edx ;偏移;创建0号描述符可以跳过;创建1，数据段，对应0-4GB空间mov dword [ebx + 0x08],0x0000ffff ; 段界限为0xffffmov dword [ebx + 0x0c],0x00cf9200 ; 粒度4kB，;创建2，代码段，mov dword [ebx + 0x10],0x7c0001ff ; 基地址是0x7c00，界限0x1ff，代码是从7c00开始的mov dword [ebx + 0x14],0x00409800 ; 粒度为1字节;创建3，堆栈段mov dword [ebx + 0x18],0x7c00fffe ; 基地址7c00，界限0xFFFE，另名代码段mov dword [ebx + 0x1c],0x00cf9600 ; 粒度4KB;创建4，显示缓冲区mov dword [ebx + 0x20],0x80007fff ; 基地址B800，界限0x7fffmov dword [ebx + 0x24],0x0040920b ; 粒度为1字节;初始化GFDTRmov word [cs:pgdt+0x7c00],39 ; 描述符界限lgdt [cs:pgdt+0x7c00] ;我们代码运行在7c00处，pgdt拿到的是相对7c00的偏移量;其他工作 打开A20in al,0x92or al,0000_0010Bout 0x92,al;打开开关cli ;关闭中断mov eax,cr0or eax,1mov cr0,eax ;进入保护模式jmp 0x0010:flush ;0x0010是选择子代码段，这里是因为当前主引导就已经在7c00了[bits 32]flush:  ;初始化数据段和堆栈  mov eax,0x0008 ;选择子-&gt;0000000000001000 -数据段  mov ds,eax  mov eax,0x0018 ;堆栈段  mov ss,eax  xor esp,esp   ;加载系统核心程序  mov edi,core_base_address  mov eax,core_start_sector  mov ebx,edi  call read_hard_disk_0 ;从指定的扇区中读写数据到指定位置  ;判断核心程序的大小  mov eax,[edi] ;核心程序的尺寸  xor edx,edx  mov ecx,512  div ecx ;每个扇区为512字节，所以除以512  or edx,edx  jnz @1 ;判断余数是否为0，不为0，则说明还有扇区没有读完  dec eax ;这里保存着除数，除数为核心程序大小的扇区数，因为前面已经读了一个扇区了，所以减一@1:  or eax,eax ; 考虑程序&lt;=512的情况，就只有一个扇区  jz setup  ;如果还有  mov ecx,eax  mov eax,core_start_sector  inc eax ;从下一个扇区开始读@2:  call read_hard_disk_0  inc eax  loop @2 ;此时这里的ecx就是所有的扇区数量，读完为止setup:  mov esi,[pgdt+0x7c00+0x02]  ;创建公用例程描述符  mov eax,[edi+0x04] ;公共例程段的偏移，在core中定义的  mov ebx,[edi+0x08]; 核心数据段偏移  sub ebx,eax  dec ebx ;公共例程段界限 （代码量-1）  add eax,edi ;公共例程段的基地址4000+相对偏移  mov ecx,0x00409800 ;代码段描述符  call make_gdt_descriptor  mov [esi+0x028],eax  mov [esi+0x02c],edx  ;建立核心数据段描述符  mov eax,[edi+0x08]                 ;核心数据段起始汇编地址  mov ebx,[edi+0x0c]                 ;核心代码段汇编地址   sub ebx,eax  dec ebx                            ;核心数据段界限  add eax,edi                        ;核心数据段基地址  mov ecx,0x00409200                 ;字节粒度的数据段描述符   call make_gdt_descriptor  mov [esi+0x30],eax  mov [esi+0x34],edx   ;建立核心代码段描述符  mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址  mov ebx,[edi+0x00]                 ;程序总长度  sub ebx,eax  dec ebx                            ;核心代码段界限  add eax,edi                        ;核心代码段基地址  mov ecx,0x00409800                 ;字节粒度的代码段描述符  call make_gdt_descriptor  mov [esi+0x38],eax  mov [esi+0x3c],edx  mov word [pgdt+0x7c00],63 ;添加了内核描述符，更新GDT  lgdt [pgdt+0x7c00]  ;至此内核程序加载全部完成，正式进入内核段进行执行  jmp far [edi+0x10] ;edi+0x10是内核入口偏移，core中定义;=============================================================================make_gdt_descriptor:  ;构造描述符，eax：基地址，ebx：段界限，ecx：属性。返回一个完整的描述符  ;前32位  mov edx,eax  sh1 eax,16 ;左移16位，保留低16位的基地址  or ax,bx ;将bx中的段界限放入低16位  and edx,0xffff0000 ;清除低16位  rol edx,8 ;循环左移8位，重新排列  bswap edx ;字节交换  xor bx,bx ;清零  or edx,ebx   or edx,ecx  ret;=============================================================================read_hard_disk_0:  ;负责从硬盘读一个逻辑扇区，eax为扇区号，ds:ebx为目标地址  push eax  push ecx  push edx  push eax  ;读取扇区数1  mov dx,0x1f2  mov al,1  out dx,al  ;发送逻辑扇区号32位，进行拆分发送  inc dx ;0x1f3  pop eax  out dx,al  inc dx ;0x1f4  mov cl,8  shr eax,cl  out dx,al  inc dx ;0x1f5  shr eax,cl  out dx,al   inc dx ;0x1f6  shr eax,cl  or al,0xe0  out dx,al  inc dx ;0x1f7  mov al,0x20 ;读命令  out dx,al.waits:  in al,dx ;从dx中读状态给ax  and al,0x88 ;只关注7.3号位  cmp al,0x88 ;都为1则处理完成  jnz .waits  mov ecx,256 ;总共读256个字  mov dx,0x1f0 .readw:  in ax,dx ;从0x1f0中读一个字给ax  mov [ebx],ax  add ebx,2  loop .readw  ;读写完成  pop edx  pop ecx  pop eax  ret;============================================================================pgdt: dw 0  dd 0x00007e00 ;GDT物理地址\n\n内核代码：\n;-------------------------------------------------------------------------------         ;以下常量定义部分。内核的大部分内容都应当固定                ;!!!!注意常量的定义并不占内存空间，也就是说实际的开始地址依然是下面的core_length         core_code_seg_sel     equ  0x38    ;内核代码段选择子         core_data_seg_sel     equ  0x30    ;内核数据段选择子          sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子          video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子         core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子         mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子;-------------------------------------------------------------------------------         ;以下是系统核心的头部，用于加载核心程序          core_length      dd core_end       ;核心程序总长度#00         sys_routine_seg  dd section.sys_routine.start                                            ;系统公用例程段位置#04         core_data_seg    dd section.core_data.start                                            ;核心数据段位置#08         core_code_seg    dd section.core_code.start                                            ;核心代码段位置#0c         core_entry       dd start          ;核心代码段入口点#10                          dw core_code_seg_sel;================================================================================[bits 32];=================================================================================SECTION sys_routine vstart=0 ;公共例程段;字符串显示put_string:  push ecx  .getc:  mov cl,[ebx] ;要显示的字符   or cl,cl ;判断是否为0  jz .exit  call put_char  inc ebx  jmp .getc  .exit:  pop ecx  retf ;段间返回 ;================================================================================ put_char:                                   ;在当前光标处显示一个字符,并推进                                            ;光标。仅用于段内调用                                             ;输入：CL=字符ASCII码          pushad         ;以下取当前光标位置         mov dx,0x3d4         mov al,0x0e         out dx,al         inc dx                             ;0x3d5         in al,dx                           ;高字         mov ah,al         dec dx                             ;0x3d4         mov al,0x0f         out dx,al         inc dx                             ;0x3d5         in al,dx                           ;低字         mov bx,ax                          ;BX=代表光标位置的16位数         cmp cl,0x0d                        ;回车符？         jnz .put_0a         mov ax,bx         mov bl,80         div bl         mul bl         mov bx,ax         jmp .set_cursor  .put_0a:         cmp cl,0x0a                        ;换行符？         jnz .put_other         add bx,80         jmp .roll_screen  .put_other:                               ;正常显示字符         push es         mov eax,video_ram_seg_sel          ;0xb8000段的选择子         mov es,eax         shl bx,1         mov [es:bx],cl         pop es         ;以下将光标位置推进一个字符         shr bx,1         inc bx  .roll_screen:         cmp bx,2000                        ;光标超出屏幕？滚屏         jl .set_cursor         push bx                            ;为了修改原书程序的逻辑问题，新增         push ds         push es         mov eax,video_ram_seg_sel         mov ds,eax         mov es,eax         cld         mov esi,0xa0                       ;小心！32位模式下movsb/w/d          mov edi,0x00                       ;使用的是esi/edi/ecx          mov ecx,1920         rep movsw         mov bx,3840                        ;清除屏幕最底一行         mov ecx,80                         ;32位程序应该使用ECX  .cls:         mov word[es:bx],0x0720         add bx,2         loop .cls         pop es         pop ds         ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除         pop bx                             ;为了修改原书程序的逻辑问题，新增         sub bx,80                          ;为了修改原书程序的逻辑问题，新增  .set_cursor:         mov dx,0x3d4         mov al,0x0e         out dx,al         inc dx                             ;0x3d5         mov al,bh         out dx,al         dec dx                             ;0x3d4         mov al,0x0f         out dx,al         inc dx                             ;0x3d5         mov al,bl         out dx,al         popad         ret                          ;================================================================================read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区                                            ;EAX=逻辑扇区号                                            ;DS:EBX=目标缓冲区地址                                            ;返回：EBX=EBX+512         push eax          push ecx         push edx           push eax            mov dx,0x1f2         mov al,1         out dx,al                          ;读取的扇区数         inc dx                             ;0x1f3         pop eax         out dx,al                          ;LBA地址7~0         inc dx                             ;0x1f4         mov cl,8         shr eax,cl         out dx,al                          ;LBA地址15~8         inc dx                             ;0x1f5         shr eax,cl         out dx,al                          ;LBA地址23~16         inc dx                             ;0x1f6         shr eax,cl         or al,0xe0                         ;第一硬盘  LBA地址27~24         out dx,al         inc dx                             ;0x1f7         mov al,0x20                        ;读命令         out dx,al  .waits:         in al,dx         and al,0x88         cmp al,0x08         jnz .waits                         ;不忙，且硬盘已准备好数据传输          mov ecx,256                        ;总共要读取的字数         mov dx,0x1f0  .readw:         in ax,dx         mov [ebx],ax         add ebx,2         loop .readw         pop edx         pop ecx         pop eax           retf                               ;段间返回 allocate_memory:  ;分配内存，ecx为分配的字节数，输出ecx为起始位置  push ds  push eax  push ebx  mov eax,core_data_seg_sel ;ds指向数据段  mov ds,eax  ;定位到要分配的物理地址  mov eax,[ram_alloc] ;起始地址   add eax,ecx ;分配完成的地址  mov ecx, [ram_alloc] ;这里已经是本次分配得到的位置  mov ebx,eax  and ebx,0xfffffffc  add ebx,4 ;数据对齐  test eax,0x00000003 ;判断是否已经对齐  cmovnz eax,ebx  mov [ram_alloc],eax ;这里存的是下次请求分配时的位置  pop ebx  pop eax  pop ds  retf;================================================================================set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符                                            ;输入：EDX:EAX=描述符                                             ;输出：CX=描述符的选择子         push eax         push ebx         push edx           push ds         push es           mov ebx,core_data_seg_sel          ;切换到核心数据段         mov ds,ebx         sgdt [pgdt]                        ;以便开始处理GDT         mov ebx,mem_0_4_gb_seg_sel         mov es,ebx         movzx ebx,word [pgdt]              ;GDT界限          inc bx                             ;GDT总字节数，也是下一个描述符偏移          add ebx,[pgdt+2]                   ;下一个描述符的线性地址            mov [es:ebx],eax         mov [es:ebx+4],edx           add word [pgdt],8                  ;增加一个描述符的大小              lgdt [pgdt]                        ;对GDT的更改生效             mov ax,[pgdt]                      ;得到GDT界限值         xor dx,dx         mov bx,8         div bx                             ;除以8，去掉余数         mov cx,ax                             shl cx,3                           ;将索引号移到正确位置          pop es         pop ds         pop edx         pop ebx         pop eax           retf ;-------------------------------------------------------------------------------make_seg_descriptor:                        ;构造存储器和系统的段描述符                                            ;输入：EAX=线性基地址                                            ;      EBX=段界限                                            ;      ECX=属性。各属性位都在原始                                            ;          位置，无关的位清零                                             ;返回：EDX:EAX=描述符         mov edx,eax         shl eax,16         or ax,bx                           ;描述符前32位(EAX)构造完毕         and edx,0xffff0000                 ;清除基地址中无关的位         rol edx,8         bswap edx                          ;装配基址的31~24和23~16  (80486+)         xor bx,bx         or edx,ebx                         ;装配段界限的高4位         or edx,ecx                         ;装配属性         retf;-------------------------------------------------------------------------------;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助put_hex_dword:                              ;在当前光标处以十六进制形式显示                                            ;一个双字并推进光标                                            ;输入：EDX=要转换并显示的数字                                            ;输出：无         pushad         push ds         mov ax,core_data_seg_sel           ;切换到核心数据段         mov ds,ax         mov ebx,bin_hex                    ;指向核心数据段内的转换表         mov ecx,8  .xlt:         rol edx,4         mov eax,edx         and eax,0x0000000f         xlat         push ecx         mov cl,al         call put_char         pop ecx         loop .xlt         pop ds         popad         retf;=================================================================================SECTION code_data vstart=0 ;核心数据段  pgdt             dw  0             ;用于设置和修改GDT                   dd  0  ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址  ;符号地址检索表  salt:  ;这里表示着对应的符号名称，例如@PrintString，表示着在程序中调用的函数名，但实际对应的是put_string方法  ;同理，@ReadDiskData，表示着在程序中调用的函数名，但实际对应的是read_hard_disk_0方法    ;用户程序加载的时候内核的任务是对比这两张salt表，将哦那个户程序salt表中的符号名切换为相应的入口地址        salt_1           db  &#x27;@PrintString&#x27;              times 256-($-salt_1) db 0                  dd  put_string                  dw  sys_routine_seg_sel  salt_2           db  &#x27;@ReadDiskData&#x27;              times 256-($-salt_2) db 0                  dd  read_hard_disk_0                  dw  sys_routine_seg_sel  salt_3           db  &#x27;@PrintDwordAsHexString&#x27;              times 256-($-salt_3) db 0                  dd  put_hex_dword                  dw  sys_routine_seg_sel  salt_4           db  &#x27;@TerminateProgram&#x27;              times 256-($-salt_4) db 0                  dd  return_point                  dw  core_code_seg_sel  salt_item_len   equ $-salt_4  salt_items      equ ($-salt)/salt_item_len  message_1        db  &#x27;  If you seen this message,that means we &#x27;                  db  &#x27;are now in protect mode,and the system &#x27;                  db  &#x27;core is loaded,and the video display &#x27;                  db  &#x27;routine works perfectly.&#x27;,0x0d,0x0a,0  message_5        db  &#x27;  Loading user program...&#x27;,0    do_status        db  &#x27;Done.&#x27;,0x0d,0x0a,0    message_6        db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a                  db  &#x27;  User program terminated,control returned.&#x27;,0  bin_hex          db &#x27;0123456789ABCDEF&#x27;                                    ;put_hex_dword子过程用的查找表  core_buf   times 2048 db 0         ;内核用的缓冲区  esp_pointer      dd 0              ;内核用来临时保存自己的栈指针     cpu_brnd0        db 0x0d,0x0a,&#x27;  &#x27;,0  cpu_brand  times 49 db 0  cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0;================================================================================SECTION core_code vstart=0 ;核心代码段;加载并重定位用户程序;esi 起始逻辑扇区号，返回ax：用户程序头部选择子load_relocate_program:  push ebx  push ecx  push edx  push esi  push edi  push ds  push es   mov eax,core_data_seg_sel ;指向内核数据段  mov ds,eax   mov eax,esi  mov ebx,core_buf  call sys_routine_seg_sel:read_hard_disk_0 ;将在50号逻辑扇区的用户程序复制到core_buf缓冲区    ;复制完成后  ;判断程序大小  mov eax,[core_buf] ; 这里的理由和前面一样，定义的时候就是放在第一行的  mov ebx,eax  and ebx,0xfffffe00 ;清除低9位，等于➗512并取整  add ebx,512 ;补齐512  test eax,0x000001ff ;检查低9位是否为0  cmovnz eax,ebx ;不为0就将对齐后的设为eax，cmovnz : 如果为非零则将源数据复制给目标数据  ;此时已经获取了程序大小在eax中，请求分配内存空间  mov ecx,eax  call sys_routine_seg_sel:allocate_memory  ;分配后ecx保存了分配的起始地址  mov ebx,ecx                   push ebx                       xor edx,edx  mov ecx,512  div ecx  mov ecx,eax ;总扇区数  ;切换ds到0-4GB的段，好加载用户程序  mov eax,mem_0_4_gb_seg_sel  mov ds,eax    mov eax,esi ;起始扇区号.b1:  call sys_routine_seg_sel:read_hard_disk_0 ;老规矩读扇区  inc eax  loop .b1  ;读完整个用户程序的扇区  ;和之前一样，创建程序的头部描述符、代码描述符等  pop edi                            ;恢复程序装载的首地址   mov eax,edi                        ;程序头部起始线性地址  mov ebx,[edi+0x04]                 ;段长度  dec ebx                            ;段界限   mov ecx,0x00409200                 ;字节粒度的数据段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x04],cx               ;建立程序代码段描述符  mov eax,edi  add eax,[edi+0x0c]                 ;代码起始线性地址  mov ebx,[edi+0x10]                 ;段长度  dec ebx                            ;段界限  mov ecx,0x00409800                 ;字节粒度的代码段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x0c],cx  ;建立程序数据段描述符  mov eax,edi  add eax,[edi+0x14]                 ;数据段起始线性地址  mov ebx,[edi+0x18]                 ;段长度  dec ebx                            ;段界限  mov ecx,0x00409200                 ;字节粒度的数据段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x14],cx  ;建立程序堆栈段描述符  mov eax,edi  add eax,[edi+0x1c]                 ;数据段起始线性地址  mov ebx,[edi+0x20]                 ;段长度  dec ebx                            ;段界限  mov ecx,0x00409200                 ;字节粒度的数据段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x1c],cx  ;重定位SALT  ;用ds:esi指向内核-salt，es：edi指向用户的salt  mov eax,[edi+0x04]  mov es,eax     ;es指向程序头部              mov eax,core_data_seg_sel  mov ds,eax  ;ds指向内核数据段  cld ;修改df，使得cmps按正向比较  mov ecx,[es:0x24] ;用户程序salt的条目数  mov edi,0x28  ;用户salt的位置.b2:  push ecx  push edi    mov ecx,salt_items  mov esi,salt.b3:  push edi   push esi  push ecx  mov ecx,64  repe cmpsd ;重复比较双字，当不匹配或者计数器为0时停止  jnz .b4  mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据  mov [es:edi-256],eax               ;将字符串改写成偏移地址  mov ax,[esi+4]  mov [es:edi-252],ax                ;以及段选择子.b4:  pop ecx  pop esi  add esi,salt_item_len  pop edi                            ;从头比较  loop .b3  pop edi  add edi,256  pop ecx  loop .b2  mov ax,[es:0x04] ;返回用户程序头部段的段选择子  pop es                             ;恢复到调用此过程前的es段   pop ds                             ;恢复到调用此过程前的ds段  pop edi  pop esi  pop edx  pop ecx  pop ebx  ret  ;-------------------------------------------------------------------------------start:  mov ecx,core_data_seg_sel ;指向核心数据段  mov ds,ecx  mov ebx,message_1  call sys_routine_seg_sel:put_string ;显示了message_1的内容  ;显示处理器的品牌信息  mov eax,0x80000002  cpuid  mov [cpu_brand + 0x00],eax  mov [cpu_brand + 0x04],ebx  mov [cpu_brand + 0x08],ecx  mov [cpu_brand + 0x0c],edx  mov eax,0x80000003  cpuid  mov [cpu_brand + 0x10],eax  mov [cpu_brand + 0x14],ebx  mov [cpu_brand + 0x18],ecx  mov [cpu_brand + 0x1c],edx  mov eax,0x80000004  cpuid  mov [cpu_brand + 0x20],eax  mov [cpu_brand + 0x24],ebx  mov [cpu_brand + 0x28],ecx  mov [cpu_brand + 0x2c],edx  mov ebx,cpu_brnd0  call sys_routine_seg_sel:put_string  mov ebx,cpu_brand  call sys_routine_seg_sel:put_string  mov ebx,cpu_brnd1  call sys_routine_seg_sel:put_string  mov ebx,message_5  call sys_routine_seg_sel:put_string  mov esi,50 ;用户程序位于50号逻辑扇区  call load_relocate_program  ;此时用户程序已经完成加载和符号表的重定向  mov ebx,do_status  call sys_routine_seg_sel:put_string    mov [esp_pointer],esp ;临时保存堆栈指针  mov ds,ax ;ds指向用户程序头部段  jmp far [0x08] ;0x08是用户程序头部选择子  return_point:  ;从用户程序返回控制权给内核  ;指向内核数据段  mov eax,core_data_seg_sel  mov ds,eax  ;指向内核堆栈段  mov eax,core_stack_seg_sel  mov ss,eax  mov esp,[esp_pointer]  mov ebx,message_6  call sys_routine_seg_sel:put_string  hlt\n\n用户程序代码：\n;===============================================================================SECTION header vstart=0         program_length   dd program_end          ;程序总长度#0x00              head_len         dd header_end           ;程序头部的长度#0x04         prgentry         dd start                ;程序入口#0x08         code_seg         dd section.code.start   ;代码段位置#0x0c         code_len         dd code_end             ;代码段长度#0x10         data_seg         dd section.data.start   ;数据段位置#0x14         data_len         dd data_end             ;数据段长度#0x18         stack_seg        dd section.stack.start  ;栈段位置#0x1c         stack_len        dd stack_end            ;栈段长度#0x20         ;-------------------------------------------------------------------------------         ;符号地址检索表         salt_items       dd (header_end-salt)/256 ;#0x24         salt:                                     ;#0x28         PrintString      db  &#x27;@PrintString&#x27;                     times 256-($-PrintString) db 0         TerminateProgram db  &#x27;@TerminateProgram&#x27;                     times 256-($-TerminateProgram) db 0         ReadDiskData     db  &#x27;@ReadDiskData&#x27;                     times 256-($-ReadDiskData) db 0header_end:;===============================================================================SECTION data vstart=0         buffer times 1024 db  0         ;缓冲区         message_1         db  0x0d,0x0a,0x0d,0x0a                           db  &#x27;**********User program is runing**********&#x27;                           db  0x0d,0x0a,0         message_2         db  &#x27;  Disk data:&#x27;,0x0d,0x0a,0data_end:;===============================================================================SECTION stack vstart=0        times 2048        db 0                    ;保留2KB的栈空间stack_end:;===============================================================================      [bits 32];===============================================================================SECTION code vstart=0start:        ; ds指向用户程序头部段         mov eax,ds         mov fs,eax         mov ss,[fs:stack_seg]         mov esp,stack_end         mov ds,[fs:data_seg]         mov ebx,message_1         call far [fs:PrintString]         mov eax,100                         ;逻辑扇区号100         mov ebx,buffer                      ;缓冲区偏移地址         call far [fs:ReadDiskData]          ;段间调用         mov ebx,message_2         call far [fs:PrintString]         mov ebx,buffer         call far [fs:PrintString]           ;too.         jmp far [fs:TerminateProgram]       ;将控制权返回到系统code_end:;===============================================================================SECTION trail;-------------------------------------------------------------------------------program_end:\n","tags":["win32 实模式到保护模式"]},{"title":"“汇编语言王爽（第4版）--实验13”","url":"/2025/11/03/%E2%80%9C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%8B%E7%88%BD%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89-%E5%AE%9E%E9%AA%8C13%E2%80%9D/","content":"该实验为编写并安装int 7ch中断例程，显示一个用0结束的字符串，并将中断例程安装到0:200处\n测试程序t1.asm用于触发7ch中断\nassume cs:codedata segment  db &quot;welcome to masm! &quot;,0data endscode segment  start: mov dh,10  mov dl,10  mov cl,2  mov ax,data  mov ds,ax  mov si,0  int 7ch  mov ax,4c00h  int 21hcode endsend start\n\n我们分析一下安装 int 7ch的主要步骤\n\n编写中断例程处理代码\n拷贝整个处理代码到0:200h\n覆盖7ch的地址，使之指向0:200h\n\n由此，可以得到一下代码\nassume cs:codecode segmentstart:  ;复制中断列程处理代码  mov ax,cs  mov ds,ax  mov si,offset do0  mov ax,0  mov es,ax  mov di,200h  mov cx,offset do0End - offset do0  cld  rep movsb  ;修改中断向量表  mov ax,0  mov es,ax  mov word ptr es:[7ch*4],200h  mov word ptr es:[7ch*4+2],0    mov ax, 4c00h ;复制完成后就退出  int 21h  ;实现输出显示在屏幕do0:   mov bl,cl  mov ax,0b800h  mov es,ax  mov di,10*160+36*10 ;屏幕中间显示  mov cx,17  s: mov al,[si]  ;循环从ds中提取数据写入缓冲区  mov ah,bl  mov es:[di],ax  inc si  add di,2  loop s  iretdo0end:  nop  code endsend start\n\n最终呈现效果：\n\n","tags":["learning-rookie"]},{"title":"利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查","url":"/2025/11/07/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E6%8F%90%E9%AB%98%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E6%9F%A5/","content":"利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查\n智能合约（SCs）是区块链平台上自动执行的程序，正在通过自动化、无需信任的交易改变银行、医疗保健和供应链等行业。然而，它们固有的脆弱性导致了严重的财政和业务损失，大规模的攻击造成了重大的经济损失。机器学习（ML）已经成为一种很有前途的SC漏洞检测方法，但其有效性、适应性和通用性仍未得到充分探索。本文对当前以太坊SC漏洞和攻击进行了全面分类。它还调查了108种基于ml的检测方法，涵盖了传统模型和高级方法的结构化分类，如基于gnn的、基于llm的、对比学习、集成、混合、元学习和迁移学习技术。系统分析了这些方法的优势、局限性和实际挑战，特别关注检测阶段、分类问题、数据集特征、特征工程、性能评估、可泛化性、检测能力、模型老化以及伦理和隐私影响等因素。此外，对SC漏洞的现有数据集进行了审查和整合。通过整合这些见解，这项工作为构建安全、有弹性和值得信赖的SC生态系统提供了可操作的指导方针和基础。\n\n1.概述区块链技术最初于2008年推出，用于支持比特币加密货币，并已发展到支持广泛的应用。基于区块链的应用程序，如分散的医疗监控，可以在不依赖中央机构[6]的情况下实现交易各方之间的直接通信。第二代区块链主要以以太坊为代表，引入了智能合约（SCs），使现实世界的分散应用程序（DApps）能够跨越金融、预测市场和物联网（IoT）等领域。\n虽然有这些优点，SC也面临重大安全挑战。开发人员的有限经验，加上编程语言的缺陷，造成了可利用的漏洞。根据SlowMist的数据，2024年，SC漏洞造成了99起事件和2.14亿美元的损失，截至2025年中期，加密货币总损失约为2.63亿美元。除了金融盗窃，SC法律还允许篡改攻击，例如虚假数据注入，威胁数据完整性。最近的几个高影响漏洞进一步说明了这些风险。\n在2024年，Penpie在其市场创建过程中由于SC逻辑缺陷遭受了2735万美元的漏洞攻击，而Hedgey Finance则因输入验证漏洞损失了4470万美元。在2023年，值得注意的事件包括对Euler Finance的1.97亿美元攻击，对BonqDAO的1.2亿美元漏洞，以及由Vyper编译器漏洞引起的7350万美元的Curve Finance漏洞。这些事件凸显了当前安全措施中持续存在的漏洞。\nSCs的安全性已成为一个突出的研究热点。传统的分析方法，如静态和形式分析、符号执行、混淆和代码合成，已被用于检测漏洞，但它们面临着关键的局限性，包括依赖源代码或局限于已知的漏洞模式。这些差距激发了人们对机器学习（ML）技术的兴趣，这种技术可以推广到固定模式之外，并提供自动化、可扩展和自适应的检测\n然而，选择合适的机器学习范式仍然是一个挑战，因为模型在漏洞检测方面的有效性各不相同。传统的异常检测方法，如一类支持向量机（OCSVM）和隔离森林（IF），已经进行了探索，但往往表现不佳。这些模型依赖于统计异常值检测，无法捕获合约执行逻辑、控制流和合约之间的交互。与欺诈检测不同的是，欺诈检测中的异常通常是数字的，而SC威胁源于执行行为、操作码序列和合约相关性。因此，OCSVM和IF无法检测到诸如重入和交叉合约破坏等漏洞，这些漏洞涉及超出分布偏差的语义不一致\n以太坊是DApps的龙头平台，得到了广泛采用、高交易量和活跃的开发者社区的支持。它也是SC安全研究中研究最多的，特别是基于ml的漏洞检测。虽然大多数基于ml的技术都是为以太坊sc开发的，但许多技术都有可能转移到以太坊虚拟机（EVM）兼容的区块链，如币安智能链（BSC）。相比之下，由于SC设计、共识机制和执行环境的差异，它们对非evm区块链（例如Solana）的适用性仍未得到充分探索。这些限制表明需要专门的基于ml的检测方法，并强调跨链SC安全是一个有前途的研究方向\n先前的工作已经充分地研究了SC安全性，如表1所示。早期的研究根据生命周期阶段和攻击类型提出了SC漏洞的基本分类，并确定了更广泛的SC安全挑战。后来的研究通过分析真实世界的攻击、确定根本原因和评估缓解策略扩大了范围。SC安全性也通过软件开发生命周期的视角进行了研究，突出了合约设计和部署不同阶段的漏洞。其他工作评估了安全工具，比较了检测系统和入侵技术，同时总结了关键限制。为了支持威胁建模和自动化，已经提出了漏洞、漏洞利用和检测方法之间的结构化分类法和映射。最近的研究主要集中在基于机器学习的方法上，提供了对检测模型、数据集和评估框架的全面回顾\n然而，在当前的SC脆弱性分析中，仍然存在一些关键的限制。有限的覆盖仍然是一个挑战，因为新的漏洞不断出现，需要定期进行全面的审查，以监测趋势和评估现有的安全措施。不一致的命名和缺乏标准化的SC漏洞标签阻碍了比较和清晰度。过时或不完整的分类法范围不同，需要整合。漏洞和攻击之间的映射不足仍然是一个问题，因为漏洞经常作为入口点，但是很少有评论系统地将它们与已知的漏洞联系起来。\n\n在基于机器学习的检测领域，仍然存在一些挑战。机器学习解决方案没有按照它们检测到的漏洞进行一致的分类，限制了比较分析。现有的研究往往缺乏对研究差距的全面评估，这是指导未来努力所需要的。基本设计要求有效的基于ml的检测仍未确定。本文解决了这些挑战，并提出了以下关键贡献\n\n提供每个SC漏洞的详细描述，包括相关标签、DASP十大类别和相关攻击。引入了一种新的分类法来按来源对漏洞进行分类：安全问题、编程语言问题或开发问题。这种分类支持三个阶段的SC审核过程，每个阶段由一个专门的团队进行。\n对2018年至2025年3月6日发布的108种基于ML的SC漏洞检测方法，按漏洞类型和ML模型进行了回顾和分类。一种新的分类法将传统方法与高级方法区分开来，后者分为七种类型：基于gnn的、基于llm的、对比学习、集成学习、混合学习、元学习和迁移学习。每项研究在分类类型、数据集、模型、验证策略和关键特征方面进行了系统的比较，为SC漏洞检测中的监督ML提供了当前的结构化参考。\n确定开发有效的基于ml的检测方法的关键因素，并评估当前解决方案如何解决这些问题。概述了机器学习驱动SC漏洞检测的未来研究方向。\n\n本文其余部分的结构如下。第2节调查SC漏洞。第3节回顾了传统的基于ml的检测方法。第4节介绍了基于机器学习的高级方法。第5节讨论了基于ml的检测的设计考虑和未来的研究方向。第六部分对文章进行总结。\n2.智能合约漏洞分类文献中报道了几个SC漏洞，并由网络安全专家进行了分析。这些漏洞在几个方面有所不同，包括行为、严重级别和相关的攻击。本节简要讨论了用于对SC漏洞进行分类的因素，并介绍了文献中确定的漏洞\n2.1 智能合约漏洞类型文献中基于各种因素对SC漏洞进行了分类，如图1所示。一些研究根据其来源将SC漏洞分为三类。这种分类假设漏洞是由编程语言（例如，Solidity）、EVM功能或以太坊架构特征中的缺陷引起的。Qian等人提出了三层分类：solid代码层、EVM执行层和块依赖层。相比之下，Rameder等人根据共享特征将SC漏洞分为十类。\n\nZheng等人根据SC生命周期阶段将SC漏洞分为四组，其中每个阶段都有可能导致漏洞的不同挑战。其他研究人员采用了类似的方法，根据漏洞在以太坊架构层（应用程序、数据、共识和网络）中的位置对漏洞进行分类。大多数已知的SC漏洞发生在应用层。\nnikoliki等人将漏洞按严重程度分为重大危害、慷慨和贪婪。这种分类强调了sc是否可以被任何用户破坏，是否可以将资金泄露给任意用户，是否可以无限期地锁定合同资金。Chen et al.将漏洞根据利用它们的攻击分为五组：未经授权的代码执行、DoS、不公平的收入、双重支出和私钥泄露。Gupta等人将漏洞分为逻辑漏洞和结构漏洞。逻辑漏洞源于开发过程中的业务逻辑错误，而结构漏洞源于技术设计规律。kabla将它们划分为功能、开发和安全级别，而Zhou等人提出了三种替代级别：攻击、程序和机制。\n随着新的漏洞不断出现，开发预防性安全解决方案至关重要。了解每个漏洞的状态，无论是否完全解决，都是至关重要的。Kabla等人将SC漏洞分为三类：已解决、部分解决和仍然开放。该框架有助于研究人员和实践者优先考虑缓解工作。\n网络安全从业者也为SC漏洞探索做出了贡献。2018年，NCC集团推出了去中心化应用程序安全项目（DASP） Top 10，确定了十个最关键的以太坊SC漏洞。不久之后，SC弱点分类（SWC）注册表发布，列出了在Solidity代码中发现的37个漏洞。DASP前10名仅发布一次，而SWC注册表自2020年以来更新有限。2022年，企业以太坊联盟（EEA）发布了EthTrust安全级别规范1，该规范定义了sc的安全要求。2023年，OWASP2社区发布了十大SC漏洞列表，该列表于2025年更新。\n2.2 漏洞映射研究SC漏洞并分析攻击行为对于制定有效的安全解决方案至关重要。与Zhou等人一致，我们发现没有标准参考文献全面涵盖所有报告的SC漏洞，而且许多引用使用了不同的名称。为了解决这个问题，我们在表2、3和4中编写了一个统一的参考，列出了每个漏洞、它的别名、它的DASP十大类别以及相关攻击的示例。\n我们通过整合来自不同来源的漏洞和现实世界的漏洞，扩展了2.1节中讨论的先前的审查，包括同行评审的研究，SWC注册表，DASP Top10， CWE， SlowMist黑客数据库和rek .news。漏洞按根本原因系统分类，并在适用的情况下与一个或多个已记录的漏洞相关联。这种结构化的映射将理论上的漏洞类别与现实世界的攻击场景联系起来。补充资料的表S3提供了所有被引用攻击的详细信息。\n我们观察到SC漏洞通常来自三个来源：安全问题、编程语言限制或开发缺陷。图2说明了这种分类，其目的是通过使团队能够专注于特定的问题类型来简化SC审计。\n3 传统智能合约漏洞检测的ML策略3.1 基于监督ml的检测模型区分良性和脆弱的SCs是一个二元分类任务。S-ML被广泛应用于该任务，因为它能够从标记数据中学习，并且在结构化环境中表现出色。本节回顾了50种现有的基于s - ml的检测方法，并根据它们所处理的漏洞进行了分类。\n3.1.1 庞氏骗局美国证券交易委员会（SEC）将庞氏骗局定义为用新参与者的资金向现有投资者支付回报的骗局。Charles Ponzi于1919年首次提出，其结构类似于金字塔：第一级的用户为第一级的用户提供资金，使早期参与者受益，而后期参与者则遭受损失。当募集放缓或出现大规模撤资时，此类计划就会崩溃。它们分为树形、链形、瀑布形和交接型。sc使自动化，增加投资者风险和威胁区块链安全。补充材料表S4总结了基于ml的庞氏骗局 SC检测方法。\n\n\n研究强调了基于代码和基于交易的特征在检测庞氏SCs和零日攻击方面的有效性。XGB模型表明，庞氏检测在没有源代码的情况下是可行的，通过结合操作码和交易特征提高了性能。RF比XGB实现了更高的方差减少，并且可以在使用操作码特征部署后立即检测庞氏合约，但这两个模型都依赖于单一操作码频率，忽略了代码语义。基于代码的零日功能优于基于交易的功能（RF召回率：96% vs. 84%）。CatBoost和J48也达到了97%的召回率，具有排名第一的功能是基于代码.庞氏合约经常模仿交易特征中的正常行为，从而增加了错误分类的风险.\n\n结合AST和基于交易的特征改进了DT、SVM和Multinomial NB (MNB)，每个都达到了94%的召回率，MNB总体上略好。来自源代码、操作码和交易数据的TF-IDF向量等混合特征增强了gb和ET的软投票集合，实现了89.67%的准确率和2.14%的FPR。在三个精心设计的数据集上进行的测试表明，删除非贡献行为特征可以提高性能，但召回率仍低于49%。具有纯代码和混合特征的基于射频的模型显示了交易数据的边际收益（召回率提高约2%）。ADASYN过采样与AdaBoost对3克操作码特征仍然产生适度的正类召回。\n\n关键的见解:\n\n集成学习不断提高检测性能。\n操作码和字节码特征，结合有效的特征选择，对于准确和早期检测至关重要。\n处理数据泄漏和类不平衡对于可靠的检测至关重要。\n\n\n3.1.2 钓鱼和欺诈传统的网络钓鱼攻击通过欺骗电子邮件或网站来获取敏感信息。在以太坊中，网络钓鱼利用平台的去中心化造成直接的经济损失，通常通过电子邮件、网站或社交媒体分发恶意地址。蜜蜂代币ICO骗局在25小时内被盗超过100万美元，证明了它们的快速影响。已经提出了几种基于ml的检测方法来解决这个问题，如补充材料表S5所示。\n基于图的级联特征提取方法将事务建模为帐户关系，并提取多跳特征。通过过滤大多数类和应用基于lightgbm的双采样集成来解决类不平衡问题。虽然优于标准ml方法，但该模型的整体性能仍然有限。同样，在超过2000万个以太坊交易上训练的网络钓鱼检测模型通过过滤缓解了类不平衡，并使用了两种特征类型：基于账户（活动模式）和基于网络（结构）。AdaBoost的AUC最高，为92.76%，而SVM和KNN表现较差。用一个模拟异常节点的隐藏网络钓鱼框架进行测试，结果表明对规避技术的鲁棒性有限。\n\nEth-PSD用于检测使用84,664个以太坊交易的网络钓鱼骗局。通过复制网络钓鱼样本来平衡数据集，并使用多种排序技术进行特征选择。60倍交叉验证的KNN准确率为98.11%，FPR为0.9%。输入、块高度和时间戳被认为是最有信息的特征。结合历史账户活动、网络架构特征和过采样改进的集成模型。然而，缺乏类分布报告降低了调查结果的可靠性。\n在包含14个特征和4个标签的数据集上，RF的准确率为98.8%，FPR为0.05%，仅包含20%的异常事务。虽然主要目标是数据集构建，但结果表明集成模型在不平衡数据上表现良好。\n在去中心化交易所（DEXs）的背景下，当开发商推出毫无价值的代币并在吸引投资者后撤回流动性时，就会发生“拉跌”。提出了一种XGB模型，通过分析Uniswap事件和令牌特征来检测此类诈骗。该模型针对的是池创建后的第一个24小时，因为大约93%的拉地毯事件发生在这个时间段内。早期检测实现了78.90%的召回率，尽管早期性能有所下降，但仍突出了机器学习预防诈骗的潜力。\n\n关键的见解:\n\n集成模型优于单个分类器，特别是当与有效的特征选择和不平衡处理相结合时。\n处理数据不平衡并应用适当的验证技术，如过采样、特征过滤和双采样集成，可以显着提高分类精度。\n区块链特定的功能对于检测至关重要，为网络钓鱼识别提供了强大的预测能力。\n\n\n3.1.3 非法账户许多恶意活动，如庞氏骗局、冒充和彩票骗局，都源于非法账户；早期发现对于减少欺诈至关重要。已经提出了几种ML方法，如补充材料的表S6所总结。对XGB模型中最重要特征的评估表明，帐户第一次和最后一次交易之间的时间是识别其合法性的最具影响力的因素。非法账户的平均使用天数为38.4天，而合法账户的平均使用天数为136.9天。\n在使用相同平衡数据集的研究中，LGBM模型在检测欺诈性以太坊账户方面始终表现出卓越的性能。去除不相关的特征将模型的f1得分提高到高达99%，并且使用10倍交叉验证进一步提高了可靠性。然而，平衡的职业分布并不代表现实世界的情况。为了解决这个问题，在不平衡数据集上训练的检测模型也被探索。RF在历史账户数据上表现出优异的性能，但缺乏验证限制了其泛化性。\n每种类型的以太坊账户都具有不同的特征和动态交易行为，使账户活动成为账户类型的有用指标。使用历史活动数据的多类分类提高了集成模型在平衡数据上的性能，尽管观察到覆盖的迹象。XGB在不平衡数据集上取得了最好的效果；然而，只有4371个账户的有限样本量降低了普遍性。\n对自我网络微观子网特征的分析表明，非法账户之间存在差异。庞氏骗局账户的聚类系数低于网络钓鱼账户。结合子网和动态事务特性，提高了射频性能。然而，阶级分布严重倾斜，非法账户占88%，与现实情况相比，这是一个不现实的比例。\n\n关键的见解:\n\n基于增强的集成模型，特别是LGBM和XGB，是检测非法帐户的最有效方法之一\n特征选择和数据集平衡是提高准确率的关键；删除不相关的特性和维护实际的类分布有助于防止重写。\n小或不平衡的数据集限制了模型的泛化性，强调了反映真实世界非法账户分布的数据集的必要性。\n\n\n3.1.4 蜜罐合约蜜罐合约是欺骗性的sc，似乎很容易引诱攻击者，从而通过隐藏的逻辑将他们困住。2019年，共有240名用户被此类攻击利用，获利超过9万美元。这些合约诱使攻击者窃取以太币，最终耗尽他们自己的资金。在某些情况下，如彩票合同，蜜罐也会损害良性用户。补充材料表S7总结了现有的检测方法。\n由于蜜罐必须是可公开访问的才能吸引受害者，检测模型利用了基于代码的特征。LightGBM是在操作码n图特征上进行训练的，其中组合单图和双图产生了最好的结果，而添加三图只产生了边际改进。XGB混合使用了基于代码、基于事务和资金的特征。基于事务的特征单独表现最好，但当所有特征类型组合在一起时，准确性得到提高。关键特性包括合约创建者的存款频率、平均交易价值和代码长度。\n以前的方法依赖于攻击后的特征（例如，余额，调用者）或仅在执行后可用的交易历史。相比之下，改进的XGB模型排除了这些特征，并使用了通过TF-IDF和word2vec提取的基于字节码的特征。使用word2vec和TF-IDF，模型的pr - auc分别为90.1%和89.2%；然而，word2vec的计算成本更高。主要特征包括存款频率和余额检查，通常存在于蜜罐合同中，以评估受害者的余额。\n\n关键的见解\n\n基于增强的集成模型（如XGB和LGBM）显示出较高的检测精度。\n特征选择至关重要；结合操作码和基于事务的特性可以提高性能。\n早期检测受限于对执行后特性的依赖。基于字节码的特性很有前途，但计算成本很高。\n\n\n3.1.5 重入补充材料表S8中总结的研究解决了这种可能消耗合同资金的高影响脆弱性。动态检测框架Dynamit由两个组件组成：一个跟踪事务的监视器和一个使用行为特征和ML模型将它们分类为良性或恶意的检测器。在包含105个事务的平衡数据集上训练了6个分类器。RF实现了最高的精度（90%），当忽略平均调用堆栈深度特征时，其精度增加到94%。然而，小数据集限制了可泛化性。另一项研究提出了一个基于dl的框架，该框架将源代码分析与合同片段表示相结合，以提取语义相关的语句，并将合同分类为易受攻击或非易受攻击。这种方法有效地捕获了SC代码中的顺序和上下文模式，获得了88.26%的f1分数。\n\n关键的见解\n\nRF优于单个分类器，但其有效性受到小数据集和中等精度的限制。\nDL模型在SC代码中捕获时间模式，尽管它们目前的性能不足以用于实际部署。\n\n\n3.1.6 拒绝服务DoS是一种网络攻击，它破坏了对预期服务的访问。针对sc的各种类型的DoS攻击如表2和表4所示，相应的检测方案如补充资料表S10所示。\nSCSCAN支持两种扫描模式：Single和Batch。它采用模式匹配来检测各种SC漏洞，而DoS则使用SVM模型单独识别。该框架识别漏洞，并按颜色编码的安全级别对契约进行排序。由于在不平衡的数据集上进行训练，除了DoS（92%）之外，它对所有测试漏洞都实现了100%的检测。\n以太坊交易分析被用来检测2000个交易数据集上的低价DoS攻击，其中10%是恶意的。使用几种技术解决了类不平衡问题，其中过采样和SMOTE产生了最佳性能。DT达到了98%以上的召回率，而SVM表现最差，基于投票的模型没有达到预期。低价DoS攻击使以太坊平均交易等待时间增加了42%以上，这是一个关键的检测功能。\n\n关键的见解\n\n集成模型，特别是RF，在检测DoS攻击方面优于其他分类器。\n通过重采样技术（如过采样和SMOTE）解决数据不平衡问题，可以显著提高检测性能。\n特征选择至关重要；交易延迟是DoS价格过低的一个有力指标，强调了行为分析的价值。\n\n\n3.1.7 多重漏洞几种多漏洞检测方法旨在提高实际场景下的效率和覆盖率，如补充材料表S9所示。SoliAudit[96]使用操作码特征检测DASP十大SC漏洞，并在两种配置下进行评估：(1)n-gram与TF-IDF和七个传统ML模型进行二元分类，(2)Word2Vec与CNN进行多标签检测。两种配置都达到了高达90%的精度，TF-IDF和LR表现最好。一项后续研究证实TF-IDF是CNN分类器中Word2Vec、FastText和BoW中最有效的表示。\nxFuzz通过预测易受攻击的合约并使用模糊器扫描它们，将ML与模糊相结合，减少了搜索空间和执行时间。它检测了重入性、Tx-origin和delegatcall漏洞，而solidaudit则专注于算术和重入性。每个漏洞独立训练的基于ast的模型报告了不同的结果，平均f1得分为79%，尽管有限的数据和薄弱的验证降低了通用性。Eth2Vec应用基于nlp的EVM字节码相似性，对代码重写具有鲁棒性，但表现不佳，f1得分为57.5%。\nContractWard在早期工作的基础上，使用操作码双字符检测易受攻击的SCs。在49,502个SCs上使用One-vs-Rest策略测试了五个ML模型，六个漏洞标签的阈值为0.5。为了解决阶级不平衡问题，我们评估了两种抽样方法。使用SMOTETomek的XGB获得了最佳性能，在Macro-和micro - f1得分中超过96%，平均每SC检测时间为45秒，但无法检测到看不见的漏洞。一个相关的基于ast的模型通过比较solidfi -benchmark和SmartBugs中子节点的结构相似性，确定了8种漏洞类型。KNN的表现优于SGD，在所有指标上都达到90.10ś96.67%，超过了SmartCheck和Oyente。尽管结果很好，但有限的训练数据阻碍了推广和新漏洞的检测。\n使用增强型遗传算法（EGA）的集成框架从AST、操作码、字节码和ABI视图中提取了240个特征，并选择了前80个。对111,897个sc进行了评估，它对11种漏洞类型进行了多类分类，尽管召回率仍然中等（41ś69%）。基于ast的轻量级CNN解决了物联网资源约束问题，实现了95.23%的重入召回率。sGuard[51]结合了基于ml的检测和基于规则的修复，使用签名和缓解功能针对五种漏洞类型。虽然性能有所不同，但它在未检查调用返回值、原点和重入性方面分别实现了96%、94%和90%的召回。\nSC漏洞检测的最新进展强调混合和多模态DL框架，以提高准确性、鲁棒性和可扩展性。使用CodeBERT融合了操作码和源代码的特征，以实现高精度的异常检测。DeeSCVHunter将操作码序列和控制低图与BiLSTM和LSTM模型集成在一起，使用自关注来捕获语法和语义特征。COBRA采用字节码级方法，将基于gru的顺序建模与多尺度上下文感知模块相结合，以丰富特征表示。MODNN采用具有多目标学习的模块化深度神经网络，融合BERT嵌入的语义特征和操作码共现矩阵的结构模式，检测12种漏洞类型。\n将字节码图像、契约图和专家定义的特征与VGG16、GRU、AutoInt和DCN集成在一起的统一框架的准确率超过96%。通过Word2Vec嵌入操作码并应用Bi-GRU、Transformer和注意力增强cnn的混合模型扩展了检测能力。使用TF-IDF和基于合成模式训练的MLP的轻量级解决方案实现了91.27%的f1得分。CodeNet通过无步进CNN将字节码作为图像处理，以保持操作码局部性。一个多模态框架结合了跨源、编译和字节码表示的白盒测试，利用BiLSTM、textCNN和RF实现84种检测策略，准确率高达99.71%。\n\n关键的见解\n\n集成和深度学习模型在多漏洞检测方面优于传统分类器，尽管没有一个在所有类型中都表现出色。\n特征提取强烈影响检测；TF-IDF和AST相似度等方法通常优于深度嵌入。\n尽管最近的模型显示出对未知情况的改进的适应性，但跨漏洞类型的泛化仍然具有挑战性。\n混合和多模式模型通过集成不同的特性来增强灵活性，但它们的成功依赖于架构和数据质量。\n\n\n3.2 基于无监督ml的检测模型无监督机器学习（U-ML）在没有标记数据的情况下发现模式和异常。在SC分析中，U-ML方法检测代码结构、执行行为和事务模式的变化。聚类组通过结构相似性收缩以发现异常值，而异常检测滞后于可能表明开采的不规则气体使用或函数调用。尽管有这些功能，由于假阳性率高、操作码敏感和效率低，U-ML很少被采用。研究表明，U-ML经常将良性行为错误地分类为恶意行为。例如，Lorenz等人发现IF和Local Outlier Factor难以区分非法交易和合法交易。同样，聚类也受到操作码多样性和编译器不一致性的影响，降低了可泛化性。\n为了解决这些问题，Huang等人引入了一个基于图嵌入的字节码匹配框架。虽然对噪声和编译器不一致有效，但它仍然依赖于与已知模式的相似性，缺乏检测新漏洞的能力。更根本的是，U-ML技术不能可靠地捕获不表现为统计异常的上下文相关漏洞。由于缺乏语义理解，这些模型经常将无害的偏差错误地分类为威胁。\n经验证据突出了U-ML的局限性。OC-Detector仅获得56%的f1得分，而用于重入检测的深度聚类方法[162]报告的得分低至7.1%ś9.5%，使得U-ML不适合精确的SC漏洞识别。计算需求带来了额外的挑战。虽然基本方法（如k-means）是有效的，但复杂模型（如深度聚类）可能超出S-ML的资源需求，阻碍了约束环境中的实时检测。此外，缺少标签会使验证变得复杂。尽管有这些缺点，当标记数据不可用时，U-ML仍然有希望识别未知或零日SC漏洞。未来的工作应该探索将U-ML的异常检测与S-ML的分类精度相结合的混合模型\n4 SC漏洞检测的高级ML方法本节回顾了SC漏洞检测的高级ML技术，包括图神经网络（gnn），基于变压器的架构（例如，llm），元学习和混合方法。\n4.1 GNN-Based方法gnn是为图结构数据设计的，可以有效地捕获节点之间的复杂关系，使其非常适合SCs，可以用图编码控制低、数据依赖和函数调用来表示。补充材料的表S11总结了最近基于gnn的SC漏洞检测方法。\n一些模型通过集成控制层和语义上下文来增强图级表示。ContractGNN引入了漏洞子图（Vulnerability Sub-Graphs, vsg）来隔离cfg的关键区域。SCVHunter采用异构GAT （HGAT）来突出语义上重要的节点，在47,587个sc中，在重入性和时间戳依赖上实现了93.72%和91.07%的准确率。DA-GNN结合了基于gru的语义注意和基于gat的结构注意，在17670个SCs上超过了gcn和gru。多标签GNN使用Sent2Vec嵌入和CFGs来检测单个SC内的多种漏洞类型。\n其他模型融合了异构表示，以实现更深层次的语义理解。EtherGIS对六种漏洞类型的属性cfg应用TopK池。HG-Detector通过异构GNN集成了ast、CFGs和call graphs，实现了高达10.06%的精度提高和2.29%的f1得分增益。Cai等人通过将AST、CFG和PDG与程序切片和bi - ggnn结合起来扩展了这一点。\n特定领域和混合gnn扩大了适用性。HARDEN将GCNs应用于操作码图，用于DeFi中的可重入性检测。Peculiar将数据低图与预训练的Transformer相结合。MANDO引入了bi - ggnn的多级嵌入，而MANDO- hgt则增加了变压器层和元关系建模。StateGuard使用ast衍生的图来检测DEX合约中的状态脱轨缺陷，在5,671个sc上获得了94.25%的f1得分。\n\n关键的见解\n\ngnn通过对结构和语义关系建模，超越了静态和模糊方法，增强了SC漏洞检测。\n基于注意力和异构gnn（例如，HG-Detector, SCVHunter）通过优先考虑语义上重要的节点和关键漏洞来提高准确性。\n多标签gnn通过识别单个SC中的多种漏洞类型来扩展检测范围。\n\n\n4.2 LLM 方法llm具有高级的代码理解和推理能力，为Slither等基于规则的工具提供了数据驱动的替代方案。与静态启发式不同，llm利用上下文学习和模式识别来检测预定义签名之外的漏洞。补充材料表S12总结了基于llm的SC漏洞检测方法。\n微调模型，如DistilBERT和BERT-ATT-BiLSTM显示出强大的性能。BERT-ATT-BiLSTM在随机平衡数据集上达到了86.67%的f1得分，而DistilBERT达到了97%的准确率。然而，小样本量（520 SCs）引起了对覆盖和有限泛化的担忧。\n像PonziSleuth这样基于gpt -3.5 turbo构建的zero-shot模型，利用预训练的知识绕过了直线调谐，在检测庞氏骗局时达到了96.06%的平衡准确率。尽管如此，由于有限的任务适应，他们仍在与模糊的漏洞作斗争。多模态方法，如QuadraCode AI，结合源代码、字节码和操作码来增强鲁棒性，但增加了计算开销，限制了实时部署。\n许多基于llm的方法依赖于合成数据集或小数据集，导致偏差和弱泛化。类不平衡进一步降低了对罕见漏洞的检测准确性。可解释性是另一个挑战，因为llm作为黑盒模型运行，不像具有可追溯输出的传统工具。效率也存在问题：像ft - codellam - 13b这样的大型模型只能达到34%的准确率，强调了规模和可部署性之间的权衡。此外，微调大模型是资源密集型的，限制了它们在SC审计中的实时使用。\n将llm与符号执行相结合可以提高对新威胁的适应性。参数高效微调（PEFT）方法，包括LoRA和适配器调谐，旨在降低训练成本，同时保持性能，尽管它们在SC检测中的应用仍未得到充分探索。用真实世界契约和对抗性示例扩展训练数据集可以提高泛化能力。虽然llm在适应性和模式识别方面优于传统工具，但在数据集质量、可解释性和可扩展性方面仍然存在挑战。数据集多样性、混合模型和高效调优的进步是实现鲁棒性和可解释的基于llm的SC漏洞检测的关键。\n\n关键的见解\n\n基于llm的检测提供了强大的模式识别，但由于数据集小，合成或不平衡而缺乏泛化。\n集成传统的分析提高了准确性，但增加了复杂性，突出了对XAI和高效的优化方法的需求\n\n\n4.3 对比学习方法对比学习（CL）是一种突出的表征学习策略，它可以在不需要人工标记的情况下提取判别性和不变性特征。它通过优化正、负样本对的对比损失，在嵌入空间中将相似的实例投影得更近，而将不相似的实例投影得更远。在SC分析中，CL支持鲁棒特征学习，增强了漏洞检测能力。\n最近的研究，总结在补充材料的表S13中，将CL应用于各种SC漏洞。ContraPonzi使用一种基于自监督graphsage的编码器，其正对由同一SC的多版本编译字节码形成，而负对则来自不同SC。这种增强捕获了不变语义，性能优于所有基线。\n基于transformer的框架通过从漏洞标签构造对比对，将标签相同的合约分组为阳性，标签不同的合约分组为阴性，从而实现多类检测。该模型通过掩模语言建模（mask Language Modeling， MLM）集成了上下文增强，获得了94.52%的f1分数，优于基于规则和神经基线。ACAD侧重于使用图中心性引导的自适应CL进行重入和无限环路检测。结构增强，如边缘去除和特征掩蔽，选择性地应用以及提前停止，以提高稳定性。ACAD在Reentrancy上达到了93.87%的f1得分，但由于有限的标记数据，在infinite Loops上的表现较低。\n\n关键的见解\n\nCL方法通过从图结构数据或源代码中学习判别特征来改进SC漏洞检测。\n它们的性能取决于增强设计和自我监督策略，以减轻有限的标记数据。\n\n\n4.4 集成方法集成ML结合多个模型来提高预测精度、鲁棒性和泛化性，这些都是SC漏洞检测的关键。通过汇总来自不同分类器的输出，集成方法减少了方差和偏差，通常优于单个模型。补充材料表S14中总结了几种基于集成的方法，这些方法已显示出显著的性能增益。\nSCVDIE-Ensemble集成了多种神经网络来提高准确性和鲁棒性。基于堆叠的集成与元学习器[105]将欺诈检测召回率提高到97.18%。PonziTect应用有序增强来解决类别不平衡问题，达到97%的召回率，而AI-SPSD通过整合公共数据来扩展庞氏检测，从而提高鲁棒性。\nMuLCas采用带有阈值投票的多视图级联集成来组合来自多个分类器的预测，包括开发人员级别的特征。虽然这种方法改进了欺诈检测，但它强调了进一步优化召回的必要性。多模态决策融合方法集成了源代码、操作码和CFG特征，提高了性能，但其有效性因漏洞类型而异。软投票集成合并了在不同特征表示上训练的多个dnn的输出，减少了错误传播并提高了分类精度。\n\n关键的见解\n\n集成模型通过组合不同的分类器和特征类型来提高鲁棒性，从而更有效地检测漏洞。\n召回率和模型稳定性的可变性强调了控制集成体系结构和优化特征表示的必要性。\n\n\n4.5 混合方法混合ML模型结合了互补的学习技术来提高SC漏洞检测的准确性、鲁棒性和可扩展性。如补充材料表S15所述，最近的研究表明，这些模型在适应性和效率上都超过了独立的方法。\nSCVD-SA将cnn与自关注相结合，优先考虑关键特征，增强了对多个漏洞的检测。同样，CNN-LSTM-Attention模型同时捕获了空间和时间模式，在重入性方面的f1得分为90.20%，召回率为90.47%。CGE将gnn与专家定义的控制和数据低模式相结合，在可重入性、时间戳依赖性和无限循环方面分别获得86.41%、87.75%和82.13%的f1得分。\nReVulDL使用GraphCodeBERT融合gnn和transformer进行重入检测，而SmartDT将基于注意力的深度学习与符号执行集成在一起，以增强可解释性和远程依赖建模。Liu等人利用增强了专家规则的gnn来分析基于图的SC特征。GRU- rf将GRU与rf相结合，平衡检测精度和效率，准确率达到98.47%。然而，注意层和循环层增加了计算复杂性，强调了在大规模部署中进一步优化的必要性。\n\n关键的见解\n\n混合模型提高了检测精度，但需要进一步优化以实现可扩展性和高效部署。\n混合体系结构有限的可解释性突出了对XAI和特征归因技术的需求，以确保透明性。\n\n\n4.6 元学习方法元学习使模型能够用最少的标记数据在任务之间进行泛化，使其非常适合SC漏洞检测，其中注释的示例很少，并且经常出现新的威胁。He等人和Yang等人开发了基于模型不可知元学习（MAML）算法的框架，使用cnn在N-way K-shot设置中以EVM字节码作为输入。He等人在低数据场景下表现出优于传统模型的性能，而Yang等人报告了强有力的结果，总结在补充材料的表S16中。\n一个关键的区别在于输入表示。SC学习者-元学习者框架（SCLMF）[158]将字节码转换为RGB图像，帧检测作为图像分类任务。它在Omniglot上达到了98.5%的准确率，但在sc特定的w潦草数据集上只有72.36%，这揭示了在捕获契约语义方面的局限性。相比之下，FSL-Detect从操作码构建cfg，提取TF-IDF特征，并将MAML与CNN集成。在2-way 5-shot设置下，它达到了93.98%的f1得分，提高了30%的召回率，突出了将结构和语义特征结合起来对于sc特定上下文的价值。\n\n关键的见解\n\n元学习提高了对有限数据的适应性，但其计算开销突出了对更高效和可扩展策略的需求。\n结果表明，表示选择强烈影响现实世界的性能，领域知情建模优于基于图像的方法\n\n\n4.7 迁移学习由于数据不平衡、领域特定的特征和有限的标记实例，用于SC漏洞检测的传统ML模型通常难以推广到未见过或未充分代表的漏洞类型。迁移学习解决了这些挑战，利用知识从特征明确的漏洞，以提高对罕见或新颖类别的检测。正如补充材料表S17所总结的那样，目前的研究强调了它超越静态、单一任务模型的有效性。\nYe等人提出了一种领域自适应框架，该框架结合了用于合成数据生成的变分自编码器（VAE）和用于隔离共享和特定于领域的特征的领域分离网络（DSN）。他们的模型在检测由重入性转移的时间戳依赖漏洞方面达到了93.2%的准确率，比纯源基线高出25%。Naeem和Alali采用轻量级分类器利用句法和语义相似性进行交叉漏洞预测，报告的四个数据集的f1得分在73%到93%之间，大多数超过80%。\nQian等人引入了一种跨模态方法，其中只有字节码的学生模型使用源代码和字节码从教师模型中学习。Le等人通过定制的蒸馏器模型（与MLP和LSTM层进行线性调优）应用迁移学习，使用深度上下文化代码表示来检测可重入漏洞。\n\n关键的见解\n\n迁移学习通过域不变特征和跨类型语法相似性增强了对未见或未充分代表的SC漏洞的泛化。\n当共享特征表示可用时，DSN等轻量级模型可以有效地检测漏洞，而无需重新训练。\n\n\n4.8 比较分析传统的机器学习模型，特别是集成模型，对于SC漏洞检测仍然非常有效，一些研究报告的准确率和召回率超过95%。RF在非法账户检测方面达到98%的召回率和97.5%的准确率，而LGBM在类似任务中这两个指标的准确率为99%。即使是简单的KNN模型也能达到98%的召回率。基于集成的方法通常对单个漏洞检测最有效，但由于特征表示的限制，在多漏洞场景下性能下降。\n在单漏洞和多漏洞检测方面，先进的集成方法继续优于许多现代方法，一些研究报告了95ś98%的精度和96ś97.26%的召回率。混合架构也表现强劲，超越了传统的ML和gnn（例如，GRU RF实现了97.34ś98.3%召回率）。最近的研究越来越多地利用LLM，如GPT-4和基于codeberta的框架，其中9调优模型的召回率达到97.37%。然而，由于每类报告和异构数据集，多漏洞任务的性能比较仍然具有挑战性。\n对比学习、元学习和迁移学习等新兴学习范式通过增强适应性和泛化能力显示出强大的潜力。对比学习取得了竞争性的结果（例如，95.36%的召回率），而元学习（基于mml的）在少量射击设置下表现优异，召回率高达91.56%[64]。迁移学习进一步提高了跨数据集泛化，召回率达到91.09%。尽管探索较少，但这些方法是对现有ML框架的补充。\n不同模型类型的训练和检测时间差异很大。在回顾的传统模型中，只有RF和KNN报告较低的训练时间，只需要0.01ś0.06 s，而更复杂的模型，如EGA，需要47ś53 s来检测。cnn报道0.13ś0.15的检测次数为s。基于gnn的方法通常涉及更高的检测开销，例如，SCVHunter报告的平均检测时间为0.66 s，而ContractGNN达到2.19 s。同样，基于llm的技术表现出更高的检测时间，PonziSleuth需要5.52秒，基于gpt -3的VulnHunter需要23秒。\n考虑到它们较低的训练开销，RF（一种集成方法）和KNN（一种简单的基于实例的模型）都适合快速部署。然而，它们的实时适用性取决于推理延迟和系统约束等因素，而这些因素在所回顾的研究中没有得到检验。相比之下，gnn和llm显示更高的计算成本，使它们更适合在线分析。性能特征的总结在补充材料中提供（表S4śS17），并在第5节中进行进一步讨论。\n5 讨论以及未来的研究方向现有的基于ml的SC漏洞检测方法存在一些特点和局限性。图3概述了影响解决方案设计的关键因素，以及相关的需求。本节讨论每个因素，评估针对这些要求的当前方法，并强调未来的研究方向。\n\n5.1 检测阶段方法SC漏洞通常通过三种主要方法检测：部署前、部署后和零日检测。预部署方法，如在部署前分析SC源代码，以识别漏洞并确保安全发布。部署后的方法，例如，监视事务行为以检测异常。\n一些方法，例如，将静态代码特征与事务数据结合起来以提高准确性，尽管这些方法需要部署sc和足够的事务历史记录。零日检测方法，例如，旨在在部署后立即识别恶意sc，在任何交易之前，使其有效应对庞氏骗局和地毯拉等威胁。\n尽管部署前检测是必要的，但某些漏洞仅在执行过程中出现，而有些合约是带有恶意目的设计的。因此，全面的安全解决方案应该集成所有三个检测阶段：在部署前验证sc，在执行期间监视它们，以及在部署后立即检测零日威胁\n\n潜在的研究方向\n\n检查集成的基于ml的方法，以快速检测和预防SC漏洞。\n探索不同区块链环境中SC检测工具的有效集成点。\n优化基于ml的检测技术，在资源限制下实现可扩展、实时和链上执行。\n\n\n5.2 分类问题SCs通常包含多个漏洞，使得检测本质上是一个多标签分类问题。然而，一些基于ml的模型专注于单一的漏洞类型，限制了现实世界的适用性。\n在文献中，SC漏洞检测被视为具有多标签类的二值分类或作为一个多类问题。Momeni等人经验表明SC漏洞是独立的，证明需要为每个漏洞训练单独的二元分类器，这一方法与网络威胁检测实践一致。确定具体的脆弱性类型对于指导有针对性的缓解战略仍然至关重要。\nS-ML方法由于其结构化分类能力和对标记数据集的高准确性而获得了比U-ML方法更多的关注。然而，这种对标记数据的依赖限制了对零日漏洞和不断发展的SC结构的适应性。此外，随着新威胁的出现，为每个漏洞训练单独的模型会带来可扩展性方面的挑战\n相比之下，U-ML方法，如聚类和异常检测，显示出检测未知漏洞的潜力。然而，他们对统计偏差的依赖，而不是执行意识分析，往往导致高假阳性。此外，对操作码变化和编译器不一致的敏感性降低了它们在不同SC实现中的通用性\n\n潜在的研究方向\n\n根据网络威胁检测需求，开发能够检测各种SC漏洞的基于ml的方法。\n检查U-ML技术在零日SC漏洞检测方面的潜力，重点是执行感知模型，以减少误报并提高准确性。\n设计S-ML和U-ML相结合的混合模型，增强适应性和精度。利用图学习、变换和对比学习可以改进特征表示，用于新的威胁检测。\n\n\n5.3 数据集的特点数据集的质量、多样性和结构严重影响基于ml的SC漏洞检测的性能、鲁棒性和泛化性。如补充资料总结表S18所示，现有数据集可分为四种类型：(1)原始构建的，为特定任务从零开始构建，相关性高但资源密集；(2)合并，通过组合多个源来提高多样性，通常需要预处理来解决不一致性；(3)扩展，通过在现有数据集上添加特征或样本来提高准确性；(4)用于基准测试的其他数据集的复制、精确副本，但通常已经过时或缺乏多样性。\n在回顾的研究中，Etherscan explorer是最常用的数据源，其次是BigQuery、CryptoscamDB和dapp相关平台。所收集数据的可靠性取决于这些来源的准确性、多样性和及时性。一些被检查的数据集已经过时，缺乏反映SC漏洞和区块链技术快速发展所需的定期更新。\n此外，数据集在标签多样性、样本量和类别分布方面差异很大。许多模型样本不足或类失衡严重，限制了模型的泛化和训练的有效性。例如，970,898份合同中有34,200份是脆弱的（约占4%），突出了不平衡的严重性。\n然而，在反映现实世界条件的最佳类别比例上没有达成共识，导致不同研究的方法不一致。\n类别不平衡带来了重大挑战。机器学习模型往往偏向于大多数类别，导致对脆弱的SCs的召回率很低。像LR和SVM这样的传统算法很难从罕见的情况中学习，因为它们的损失函数由多数类数据主导。因此，在不平衡的数据集上训练的模型不能泛化，往往在错过关键漏洞的情况下获得误导性的高准确性。\n为了解决这个问题，我们研究了三个主要策略，如图4所示。数据驱动技术包括过采样、欠采样和混合采样。过采样提高了少数族裔的代表性，但可能会引入噪音和覆盖。欠采样减少了多数类样本以减少偏差，但有丢弃有价值信息的风险。混合采样平衡两者，但需要仔细调优以避免数据丢失或冗余\n\n算法驱动的方法修改了学习过程本身。其中包括类权重调整和集成学习，以减轻偏差并提高鲁棒性。虽然这些方法保留了原始数据，但它们需要仔细地进行超参数调优，如果配置不当，可能会出现覆盖或遗漏的问题。混合方法结合了这两种策略，以利用它们的优势，同时减轻个体的缺陷。然而，在选择最佳重采样比和调谐参数方面仍然存在挑战\n尽管区块链数据的可访问性，为SC漏洞检测策划的公共数据集仍然有限。许多条目过时，缺乏多样性，标签不完整，或者需要大量预处理的原始格式。这种稀缺性源于专有限制、隐私风险、高数据准备成本以及精确SC注释的技术复杂性等因素。这些挑战凸显了协作开发和维护高质量开放获取数据集的必要性\n\n潜在研究方向\n\n系统分析SC漏洞，攻击模式和关键属性，以构建高质量的数据集。从业者的输入对于控制定义和确保与现实世界的威胁保持一致至关重要。\n为SC数据集的构建、维护和扩展开发自动化的自适应框架，以确保及时更新、语义完整性和有效的模型训练。\n通过抗噪声重采样、混合采样和成本敏感学习增强不平衡处理，同时避免覆盖和保持数据多样性\n通过改进表征、重采样和损失函数来推进多标签学习，以捕获脆弱性之间的关系并解决类别不平衡问题\n\n\n5.4 功能类型如图5所示，ML模型使用了几种特征类型来检测SC漏洞和相关攻击。这些特性可以分为基于代码的、基于事务的或混合的。\n\n基于代码的特性是研究最广泛的。基于令牌的特性（补充材料的图S8）提供了丰富的语法和语义信息，但需要源代码，而源代码通常是不可用的。代码重用也会导致跨sc的字节码重复，增加数据集冗余。\n基于操作码的特征（补充材料的图S9）是从字节码中提取出来的，更适合于现实世界的场景，尽管它们的可解释性较差。混合功能(图S10的补充材料)集成表示（例如，令牌操作码）以捕获更丰富的语义，但增加了复杂性。附加的特征类型（补充材料的图S11）捕获了可选的SC行为\n基于事务的特性（补充材料的图S12）可以是静态的，也可以是动态的。静态特征捕获交易特征（例如，gas使用），而动态特征反映行为方面（例如，交易量），并可能包括基于图形的特征，将帐户交互建模为链接。需要进一步的研究来评估图特征和交叉类型组合的效用。\n基于代码的特性可以在部署前或部署后提取，从而实现早期检测，而基于事务的特性需要实时SC活动。合并代码和事务数据的混合方法通常可以提高性能，如补充材料的图S13所示。\n不同的特性类型可以检测到相同的漏洞。例如，结合账户和图形特征来检测庞氏骗局，而仅依赖于图形特征。Rizzo等人的基准测试证实了输入类型（如源、操作码、AST、CFG）显著影响检测性能。没有哪一种功能类型总是优于其他类型。多模态输入，特别是在集成模型中，通常会产生更好的结果。由于实验设置的异质性，确定一个普遍最优的特征类型仍然是不可行的。\n\n潜在的研究方向\n\n由于实验设置的异质性，现有研究对不同特征类型的有效性提供了不确定的证据。需要进行全面的实证评估，以确定检测各种SC漏洞和相关攻击的最佳特征。\n\n\n5.5 特征工程机器学习模型需要预处理数据来进行有效的训练。特征工程是选择、提取和转换相关数据属性的过程，在提高模型精度方面起着至关重要的作用。技术的选择取决于问题的性质。\n如图6所示，许多研究依赖于基于nlp的方法从原始SC数据中提取特征。一些人采用手工方法，而另一些人，如Chen等人，则提出自定义提取技术。Pragasam等人利用BigQuery平台进行自动特征采集。\n尽管消除不相关的特征可以显著提高模型性能，但图7显示，特征选择通常没有得到充分的研究。有限的选择技术的采用意味着SC漏洞检测的最佳方法仍然没有解决。\n在回顾的研究中确定了四种数据标记策略（参见图8）：(1)利用以前的提示，(2)使用SC分析工具，(3)从公共存储库检索标记的合同，以及(4)手动注释。考虑到SC漏洞不断演变的本质和攻击者使用的混淆策略，标记方法必须捕捉每个漏洞的最新模式\n\n潜在的研究方向\n\n研究各种特征提取和选择方法对SC漏洞检测中ML模型性能的影响，重点是确定基于投票的选择策略等最佳技术。\n通过鼓励专家主导对部署的SC和漏洞报告的分析，解决标记SC漏洞数据集的短缺问题。建立一个共享的、最新的公共存储库对于支持有效的基于ml的SC漏洞检测至关重要。\n\n\n5.6 绩效评估准确性、精密度、召回率、f1分数等评价指标被广泛应用于SC漏洞检测研究中。然而，这些指标经常在不平衡的数据集上产生误导性的结果。准确性忽略了类的分布。f1分数忽略了真正的否定，并且相对于类别标签是不对称的。马修斯相关系数（MCC）通过结合混淆矩阵的所有四个元素来解决这些问题，为平衡和不平衡数据集提供公正的评估。MCC只有在正确预测正面和负面类别时才会获得高分，而不管它们的比例如何。\n\n\n\n一些研究，使用SC漏洞分析工具作为评估ML模型的基线。然而，这些工具无法检测所有类型的SC漏洞，限制了它们进行全面性能比较的有效性。\n除了分类度量之外，评估训练时间、推理延迟和模型复杂性对于评估部署可行性也是必不可少的。在在线环境中，训练时间决定了模型适应新威胁的速度。在实时场景中，低推理延迟对于部署前检查和持续监控至关重要。模型复杂性不仅影响计算开销，还影响可解释性和部署的便利性，特别是在受约束或分散的环境中。尽管这些指标很重要，但它们经常被忽视，这限制了在现实条件下评估模型有效性的能力。\n\n潜在的研究方向\n\n为基于ml的SC漏洞检测采用稳健的验证策略，结合不同的度量、统计显著性测试和可视化分析工具（如箱线图）\n评估训练时间，推理延迟和模型复杂性，以确保在线分析和实时部署的适用性。\n\n\n5.7 概括性模型验证对于确保可靠和可复制的性能结果至关重要。大多数研究采用保留方法（将数据分为训练和测试），由于样本差异，可能产生不一致的结果，从而限制了通用性。虽然Zheng等人认为交叉验证不适合具有时间依赖性的数据，仍然需要健壮的验证策略。一些研究只在训练集中进行交叉验证。考虑到大多数SC数据集的规模较小，保持训练和测试数据之间的平衡分布是至关重要的。\n标记SC漏洞数据集的稀缺性仍然是一个主要挑战。这些数据集通常很小，不平衡，并且特定于领域，限制了对看不见的漏洞，契约结构，编译器版本和不断发展的语法的推广。迁移学习提供了一个很有前途的解决方案，它使模型能够跨契约类型进行泛化，尽管仍需要进一步研究在线调整和领域适应策略。\n\n潜在的研究方向\n\n通过跨越多个区块链平台的多种真实数据集，提高基于ml的漏洞检测的泛化和适应性。强调交叉验证、特征对齐和对抗性训练，以管理领域转移、不断发展的SC标准和编译器变化。\n通过迁移、在线和自监督学习提高学习效率和鲁棒性。利用相关的漏洞类别并启用增量更新来解决未见的或混淆的威胁，而无需频繁的再培训。\n使用集成表示训练的多模态和基于llm的模型提高检测精度。采用数据融合和对比调优来更好地捕获微妙的漏洞模式。\n\n\n5.8 检测能力迄今为止，没有一种基于ml的方法可以检测到所有SC漏洞；大多数方法都针对特定类型。例如，SoliAudit专注于算术和重入问题，而SCScan使用部分基于ml的架构针对DoS漏洞。这突出了传统机器学习技术的局限性，它依赖于手工制作的特征，并与看不见的攻击向量作斗争。\n\n最近的进展结合了结构和语义分析来提高覆盖率。gnn通过对代码依赖关系进行建模来增强结构推理，而转换器和llm则捕获上下文和语言级语义。元学习和对比学习促进了低数据场景下的泛化，从而能够检测新出现的漏洞。然而，在可解释性、可伸缩性和部署方面仍然存在挑战。\n图9和图10所示的对所回顾研究的比较分析表明，DT、SVM和KNN经常被应用，但套袋（RF）和提升（XGB）集成通常可以获得更好的性能，特别是在检测非法账户和庞氏骗局方面。LGBM虽然不太常见，但表现良好，这表明模型选择通常更多是由熟悉程度而不是经验证据驱动的。由于其较高的复杂度和计算成本，堆栈和投票集成很少被采用。DL模型、LSTM、Bi-LSTM和GCN由于数据集小、SC语义复杂和缺乏特定领域的架构设计而未得到充分利用。\n对于零日漏洞，gnn检测cfg、DFGs和相关图中的结构异常，但依赖于准确的图提取，语义推理有限，使得它们对微妙的攻击不太有效。llm泛化了看不见的模式，但在没有特定于领域的调优的情况下，很难处理原始字节码和运行时数据。集成方法结合多个机器学习模型来提高泛化和鲁棒性，但在面对新行为时往往会增加计算量和误报。\n迁移学习能够从预先训练的模型中进行适应，但会受到领域转移的影响。对比学习有助于异常检测，但需要精心配对，并且可解释性较差。元学习支持以最少的数据快速适应新威胁，尽管其有效性取决于预训练的多样性。结合gnn、llm和元学习为全面的零日检测提供了一个有前途的方向。\n\n\n潜在的研究方向\n\n开发基于ml的模型，能够检测各种SC漏洞，包括零日漏洞，并通过定期更新和评估来确保在不断发展的分散环境中的有效性。\n通过探索增强、套袋和自适应堆叠来推进集成方法，同时研究基础学习器的上下文感知选择和评估数据集之间的模型一致性\n通过多模态学习（例如，源代码、字节码、跟踪、审计报告）和对抗性训练增强基于llm的检测，以提高对混淆和逃避的鲁棒性。\n通过模型压缩和架构优化来解决效率挑战，从而改进混合模型。\n探索元学习以实现快速泛化，并提高可解释性，以支持实际部署。\n\n\n5.9 模型老化恶意软件的性质不断演变其防止检测的方法。因此，必须定期评估基于机器学习的漏洞检测系统；它们必须能够检测到任何新的漏洞模式。在基于ml的检测模型中应该解决的主要问题之一是模型老化&#x2F;漂移[172]。鉴于恶意软件的快速发展，大多数被分析的方法可能会随着时间的推移而急剧退化。目前基于ml的SC漏洞检测方法尚未研究漂移检测。\n\n潜在的研究方向\n\n不断发展的SC漏洞需要主动的模型漂移管理来保持检测的可靠性。研究应该探索漂移检测算法，评估漂移的严重程度、时间和受影响的特征区。\n在基于llm的检测中解决模型老化问题需要持续的学习策略来保持先前的性能。PEFT方法和自适应快速调优可以降低再培训成本，提高对新出现威胁的响应能力。\n\n\n5.10 机器学习模型的能力和效率ML模型检测SC漏洞的能力取决于它们处理和表示代码特征的方式。单个模型（例如，LR， SVM）是高效的，并且非常适合于检测简单的，基于模式的漏洞，如算术溢出和时间戳依赖，这通常涉及显式的操作码模式或数值阈值。\n集成方法（例如RF， XGB）结合多个学习器来提高性能，使它们对中等复杂的漏洞（如访问控制违规和未检查的低级调用）有效，这些漏洞涉及更微妙的特征交互。gnn对于捕获sc中的结构关系特别有效，有助于检测依赖于调用序列和内部契约行为的可重入性和授权逻辑律。\n基于转换器的模型擅长通过对SC代码的语义和句法结构建模来识别高级逻辑漏洞。混合方法，如将gnn与集成模型相结合，提供了更广泛的覆盖范围，但随之而来的是计算复杂性的增加和可解释性的降低。\n除了检测精度外，计算效率对于实时或链上使用至关重要。如补充材料表20所示，传统模型需要最少的训练和推理资源，因此适合在受限环境中部署。集成方法虽然资源更密集，但提供了折衷方案：套袋模型支持并行推理，而增强方法以顺序训练和较慢推理为代价获得更高的准确性。gnn和变压器擅长结构和语义推理，但需要大量的计算资源，限制了它们在在线或审计阶段分析中的使用。由于多层推理管道，混合模型进一步增加了开销。\n6 总结SC安全仍然是一个重大挑战，许多灾难性的攻击造成了重大的经济损失。新的SC漏洞的不断出现强调了对能够识别零日攻击的强大检测方法的需求。mlmodel在检测SC漏洞和相关攻击方面显示出越来越大的希望。在本文中，我们进行了一项最新的调查，突出了ml模型用于SC漏洞检测的潜力。我们提供了一个对已知漏洞进行定义和分类的综合参考，并根据漏洞的来源介绍了一种新的分类法：安全问题、编程语言问题和开发问题。我们对每个漏洞的传统和先进的基于ml的检测方法进行了回顾和分类，并对实证研究的关键方面进行了比较和总结。我们还概述了在开发基于ml的检测方法时需要考虑的重要因素，并确定了有希望的未来研究方向。本文可以作为对推进ml驱动的SC漏洞检测感兴趣的研究人员和实践者的详细参考\n","tags":["智能合约论文"]},{"title":"区块链安全大语言模型：系统文件综述","url":"/2025/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%BB%BC%E8%BF%B0/","content":"区块链安全大语言模型-系统文件综述摘要大型语言模型（llm）已经成为网络安全各个领域的强大工具。值得注意的是，最近的研究越来越多地探索LLM在区块链安全（BS）背景下的应用。然而，对于llm在区块链安全性方面的全部应用范围、影响和潜在约束的全面理解仍然存在差距。为了填补这一空白，我们进行了一项文献综述，重点是将llm应用于区块链安全（LLM4BS）的研究。\n我们的研究旨在全面分析和理解现有的研究，并阐明llm如何有助于提高区块链系统的安全性。通过对现有文献的彻底检查，我们深入研究了llm与区块链安全的各个方面的集成。我们探索了llm可以增强区块链安全性的机制，包括它们在智能合约审计、交易异常检测、漏洞修复、智能合约程序分析以及作为加密货币社区参与者方面的应用。此外，考虑到可扩展性、隐私问题和道德问题等因素，我们评估了与利用llm增强区块链安全性相关的挑战和限制。我们的全面审查揭示了LLM4BS任务的机会和潜在风险，为研究人员，从业者和政策制定者提供了有价值的见解。\n1.介绍随着数字时代的推进，人工智能与区块链技术的融合成为一项突破性的发展，特别是在大型语言模型（Large Language Models, llm）与不断发展的区块链安全领域相交的关键时刻。llm已经上升到区块链安全的前沿，在文本生成和理解，特别是在源代码分析方面展示了深刻的能力，这些能力反映了模仿人类的熟练程度。这种变革性的影响归功于它们庞大的数据集、复杂的架构和支撑其运营框架的深度神经网络。\nllm在识别和综合数据中的复杂模式方面的健壮性使它们成为增强区块链系统内安全措施的宝贵资产。具体来说，智能合约的细粒度分析，交易的细致审查，以及自动代码（resp.）。文本)生成是llm擅长的关键任务之一，并且效果显著。\n然而，将这些认知功能集成到区块链安全性中会遇到一系列需要考虑的挑战。应对不断发展的网络安全威胁的复杂动态，解决人工智能部署带来的道德问题，使这条轨迹既充满希望，又充满要求。尽管取得了进展，但仍然缺乏全面描述LLM在区块链安全中的应用现状和未来发展前景的工作。\n为了填补这一空白，我们试图深入研究llm在区块链安全领域的多方面作用，探索llm在区块链安全（LLM4BS）任务上的综合范围。我们首先描述跨不同领域（§2.1）的大型语言模型（LLM）应用程序的当代景观，以及区块链技术所涉及的无数安全威胁（§2.2）。然后，如表1所示，我们详细说明了LLM4BS任务的合并和进展，涉及智能合约审计、块交易检测、合约动态分析、智能合约开发和加密货币社区贡献者（§3）。此后，我们精心选择了LLM4BS任务的三个典型案例来阐明最先进的LLM4BS任务（§4），包括LLM4FUZZ ， SMARTINV , BLOCKGPT。最后，我们对LLM4BS范围内目前面临的挑战进行了深刻的论述，并为这一新兴领域的未来研究和发展提供了前瞻性的轨迹（§5）。\n\n本文的贡献如下：\n\n据我们所知，在对现有文献进行了细致的回顾之后，我们进行了第一次系统的检查，重点是将大型语言模型应用于区块链安全领域内的任务，为先进的人工智能和分布式账本系统之间的相互作用提供了开创性的探索。\n在我们的全面调查中，我们细致地记录了区块链安全领域中大型语言模型应用的现状。我们深入研究了如何在各种场景中使用大型语言模型的详细分析，从增强智能合约的可靠性到加强分布式账本系统的完整性。这揭示了这项尖端技术的多方面贡献。\n在研究的基础上，我们严格整理和总结了一系列与Large应用相关的实践学术成果加强区块链安全性的语言模型（llm）。我们还为未来的研究提出了几个有希望的途径，预计这些将在这个新兴的交叉领域催化实质性的进步和创新。\n\n2.LLM4BS概述我们在本节中提供有关LLM4BS任务的基本知识，包括§2.1中的LLM应用程序和§2.2中的区块链安全威胁。\n2.1 大语言模型的介绍本小节将解释大型语言模型（llm）的定义、特征和各种应用。\n2.1.1 LLM的定义和特点大型语言模型（llm）代表了人工智能领域的突破性进步，特别是在自然语言处理（NLP）领域。这些模型的特点是它们巨大的尺寸、深度和复杂性，使它们能够以惊人的流畅性和连贯性处理和生成类似人类的文本。llm的核心是转换器架构，这是一个强大的序列建模框架，它彻底改变了NLP领域\nLLM的定义特征包括其前所未有的规模，它涉及对包含数十亿甚至数万亿个单词的庞大文本数据语料库进行训练。这些广泛的训练数据使llm能够捕捉语言的复杂细微差别，包括语法，语义和语用，从而赋予他们对语言结构和惯例的深刻理解。此外，LLM表现出高度的生成能力，能够在广泛的任务和领域中生成上下文相关和连贯的文本。\n此外，LLM具有显著程度的适应性，这要归功于他们通过迁移学习等技术对特定应用或领域进行微调或专门化的能力。通过利用预训练模型并在特定任务数据集上对其进行微调，从业者可以定制llm来解决各种各样的NLP任务，从情感分析和语言翻译到文档摘要和会话代理。\n\n此外，LLM展示了对语言上下文的高级理解，使他们能够生成对周围文本上下文敏感的响应或预测。这种上下文感知是通过注意机制和位置编码等机制实现的，这些机制使llm能够关注输入序列的相关部分，并有效地为长期依赖关系建模。总的来说，LLM代表了人工智能研究的一个重要里程碑，并为人机交互、内容生成、信息检索等方面开启了新的可能性。它们大规模理解和生成自然语言的能力导致了各个领域的变革性应用，塑造了人工智能驱动技术的未来\n2.1.2 LLM在各个领域的应用如图1所示，LLM的多功能性和有效性使其在不同领域和应用中被广泛采用，在这些领域和应用中，LLM表现出了卓越的性能和实用性。LLM的一些值得注意的应用包括：\n自然语言理解（NLU）：LLM擅长于情感分析、命名实体识别和文本分类等任务，在这些任务中，对语义和上下文的理解至关重要通过利用他们对语言的深刻理解，LLM可以准确地分析和解释文本数据，从而实现社交媒体监控中的情感分析或客户反馈分类等任务。\n自然语言生成（NLG）：LLM精通为各种应用程序生成类似人类的文本，包括内容创建、对话系统和虚拟助手，他们能够产生连贯的和与上下文相关的反应，这使他们在任务中非常宝贵例如生成产品描述、组合个性化消息，或者在会话界面中促进自然语言交互。\n信息检索和摘要：LLM在从大量文本中提取相关信息并生成简明摘要，从而促进高效的信息检索和知识提取方面发挥着至关重要的作用。无论是总结新闻文章，从研究论文中提取关键见解，还是为文档生成摘要，LLM都提供了一个强大的解决方案，可以将大量文本数据提炼成易于消化和信息丰富的摘要\n语言翻译：LLM通过在多种语言之间提供更准确和流畅的翻译，彻底改变了机器翻译。通过利用他们丰富的语言知识和对上下文的理解，LLM可以在翻译中保留原文的意思、语气和风格，从而在包括电子商务、国际外交和多元文化交流在内的各个领域实现跨语言障碍的无缝沟通。\n对话系统： llm为会话代理和聊天机器人提供了强大的功能，使其能够与用户进行自然且符合上下文的交互。无论是协助客户进行产品查询，提供个性化建议，还是提供客户支持，基于LLM的对话系统都提供了一种用户友好且高效的沟通方式，增强了用户体验和参与度。\n代码生成：LLM越来越多地被用于生成代码片段，并通过理解和生成各种编程语言的代码来帮助开发人员完成编程任务，通过分析代码存储库和文档，llm可以生成遵循编程约定、语法规则和最佳实践的代码，从而加快开发过程，并帮助代码维护和调试\n科学研究： LLM通过分析和总结研究论文、提出假设和协助数据解释来支持科学发现。通过摄取大量的科学文献和特定领域的知识，LLM可以帮助研究人员导航不断扩大的科学文献，识别相关出版物，并提取有价值的见解，以告知他们的研究工作\n这些应用强调了LLM在广泛领域和行业中的广泛实用性和变革潜力，突出了它们在推进人工智能能力和实现人机交互方面的重要性以前所未有的复杂程度进行交互。随着LLM的不断发展和完善，他们对各个领域的影响预计将在未来几年增长，推动创新，效率和发现。\n2.2 区块链安全基础本节将讨论区块链系统的关键组件和常见安全威胁。\n2.2.1 区块链安全的关键组件区块链安全是一项多方面的工作，旨在保护在区块链网络中存储和处理的数据的完整性、机密性和可用性。区块链安全的关键组件包括：\n密码学：密码学是区块链安全性的核心，用于加密数据、验证参与者并确保事务的完整性。使用散列、数字签名和加密密钥等技术来保护数据并验证区块链上事务的真实性\n共识机制： 共识机制是管理如何验证事务并将其添加到区块链的协议。通过在网络参与者之间达成一致，共识机制确保了分布式账本的不变性和完整性。流行的共识机制包括工作量证明（PoW）权益证明（PoS）和委托权益证明（DPoS）每个人都有自己的长处和弱点。\n去中心化：去中心化是区块链安全的核心原则，在节点网络上分配控制和决策权。通过消除单点故障并降低审查或操纵的风险，去中心化增强了区块链网络的弹性和安全性。然而，实现真正的去中心化需要仔细考虑节点分布、治理结构和网络激励等因素\n智能合约安全：智能合约是自动执行的合约，具有在区块链上编码的预定义规则和条件。确保智能合约的安全性对于防止漏洞、利用和未经授权的访问至关重要。正式验证、代码审计和安全开发实践等技术被用来减轻与智能合约相关的风险，包括重入攻击、整数溢出&#x2F;下溢和未检查的外部调用\n\n2.2.2 区块链系统常见安全威胁尽管区块链技术具有固有的健壮的安全措施，但各种安全威胁和漏洞对区块链系统的完整性和功能构成了风险。我们在图2中说明了这些威胁。区块链系统中常见的安全威胁包括：\n基于共识的攻击： 基于共识的攻击利用共识机制中的漏洞进行比较。例如包括51%攻击，其中单个实体或联盟控制了网络的大部分哈希率，使他们能够操纵交易确认或执行双重支出攻击。同样，自私挖矿、日食攻击、远程攻击等攻击，都是针对特定共识协议的弱点，破坏区块链网络的安全性和可靠性\n智能合约漏洞：智能合约漏洞对区块链安全构成重大风险，因为它们可以被利用来执行未经授权的交易、消耗资金或触发意外行为。常见的智能合约漏洞包括重入攻击，攻击者在前一次调用完成之前反复调用易受攻击的合约的函数，使他们能够操纵合约的状态并窃取资金。其他漏洞，如整数溢出&#x2F;下溢、未检查的外部调用和gas限制漏洞，也可以被利用来破坏智能合约和底层区块链网络的安全性\nDeFi协议漏洞：去中心化金融（DeFi）协议由于其复杂的交互和可组合性带来了新的安全挑战。DeFi协议中的漏洞，如闪贷攻击、oracle操纵和治理漏洞，可能会给用户造成重大的经济损失，并破坏对DeFi的信任。此外，特定DeFi协议中的漏洞可能会对其他互联协议产生级联效应，从而放大安全漏洞和DeFi领域内系统风险的影响。\n辅助服务漏洞：辅助服务，如钱包、交易所、oracle和分散应用程序（DApps），是攻击者利用漏洞和破坏区块链系统安全性的入口点。辅助服务中的安全漏洞，如交易所黑客攻击、钱包漏洞或oracle操纵攻击，可能导致资金损失、对用户数据的未经授权访问或对链上交易的操纵。此外，区块链生态系统中辅助服务的互联特性放大了安全漏洞的影响，因为一个服务中的漏洞可能会传播到其他服务，从而导致大范围的中断和经济损失\n解决这些安全威胁和漏洞需要一种综合的方法，包括技术措施、最佳实践和社区协作，以加强b区块链系统的弹性和安全性。通过了解区块链安全的关键组成部分并减轻常见的安全威胁，利益相关者可以在分散的生态系统中促进更大的信任、透明度和采用，从而为全球用户推动创新和价值创造。\n3 LLM4BS任务的分类在本节中，我们将介绍一个主题分类法，该分类法旨在系统地对与区块链安全（LLM4BS）的大型语言模型相关的任务进行分类，并强调LLM在这些上下文中的功能。图3描述了LLM4BS任务的五种应用，包括智能合约代码审计§3.1、异常交易分析§3.2、智能合约动态分析§3.3、智能合约开发§3.4、加密货币社区参与者§3.5和其他潜在方向§3.6。\n3.1 LLM作为智能合约代码审核员LLM在智能合约代码审计和漏洞检测领域的应用可以简单概括如下：高级工具，如SMARTINV[31]、GPTScan[14]、David et al.[32]、Karanjai等，ContractArmor [34]， Ortu等人[35]，ASSBert [36]，PSCVFinder [37], LLM4Vuln [38], TrustLLM [39], AuditGPT [40]， Chen等[42]，Jain等[43]，PropertyGPT [41], SolGPT [44], defaligner [45], RepairBench [46], LLM-SmartAudit [47], Hyperion [48], AdvSCanner [49], S ‘ oley [50]， Jiang等[51]，XPLOGEN[52]。如表2所示，这些由大型语言模型提供支持的工具标志着从传统的、基于模式的分析方法向更具上下文意识和更全面的检查技术的巨大转变。这些尖端工具通过将不同的信息线索（包括详细描述智能合约的预期功能和事务结构的自然语言文档的细微方面）编织在一起，将其分析能力扩展到静态模式之外。\n\n通过多模态镜头集成代码和上下文数据，使这些工具具有揭示复杂逻辑疏忽和识别微妙的“机器不可审计”漏洞的能力，否则这些漏洞将逃避检测。通过吸收和解读更丰富的人类文化语言解释与代码相结合，基于LLM的工具更深入地研究了智能合约交互的复杂网络。从这种方法中获得的深刻理解不仅揭示了隐藏的漏洞，而且还加强了智能合约抵御可能导致重大财务影响的无数风险的能力。\n从本质上讲，将大型语言模型集成到智能合约分析中，标志着区块链技术在保障基础设施完整性方面的重大飞跃。它强调了人工智能与软件开发实践融合以加强安全措施的不断发展的前景。在LLM提供的敏锐见解的推动下，这种主动识别和纠正智能合约中的弱点，有助于巩固区块链交易中的信任和可靠性，从而减轻潜在的金融负债，并加强数字合约的基础。\n\n进一步扩展llm所扮演的关键角色，值得注意的是，这些模型在增强智能合约开发的整个生命周期方面具有巨大的潜力[134]。从一代到维护，LLM都是如此制定更安全、更稳健的智能合约。他们可能会在开发阶段提供建议，建议最佳实践，甚至生成符合安全指导原则的代码片段。在整个审计过程中，像gtscan和SMARTINV这样的工具可以不断学习和适应区块链技术和网络威胁不断发展的新漏洞模式。这种动态学习过程是至关重要的，因为它允许开发越来越精细的模型，这些模型甚至能够检测到最隐蔽和最复杂的漏洞。\n\n此外，LLM吸收上下文和理解与业务逻辑相关的代码的能力使他们在合同协议复杂且具有复杂逻辑的场景中特别有效。这在金融等领域尤其重要，在这些领域，智能合约管理着涉及巨额资金和众多利益相关者的交易。这样一个领域的漏洞可能会产生灾难性的影响，不仅在财务上，而且在相关实体的声誉损害方面。因此，准确有效的智能合约审计的重要性不容小觑。\nllm还通过促进开发人员、审计人员和最终用户之间的共同理解来增强整个行业的协作努力。他们用自然语言解析和解释代码的能力弥合了沟通的差距，使具有不同技术专业水平的利益相关者能够就智能合约的安全性和功能进行有意义的对话。这种合作环境促进了一种共同承担责任和积极参与解决和预防安全问题的文化。\n3.2LLM作为异常交易的分析师llm在区块链交易分析中的应用，如BLOCKGPT [28]， Nicholls等[53]和ZipZap[54]，强调了它们在进行实时监测以检测不规则或异常迹象或是可疑的行为方面的关键作用。表3中的这些工具代表了该领域的重大进步，因为它们提供了一种更动态、适应性更强的方法来识别区块链事务中的潜在威胁。\n与静态的、基于规则的系统不同，LLM能够实时处理和学习大量的交易数据，这使他们不仅能够发现已知的欺诈活动类型，还能够发现随着技术和攻击方法的发展而出现的新模式。通过利用机器学习的力量，这些模型可以不断更新他们对正常交易行为构成的理解。这种持续的学习过程对于适应区块链技术不断变化的环境和恶意行为者采用的复杂策略至关重要。\n此外，llm的适应性不仅限于模式识别，它们在理解事务上下文方面也表现出色。这包括对智能合约交互、执行跟踪、gas价格和其他交易元数据的分析，这些元数据可以提供有关交易合法性的提示。上下文分析允许LLM区分合法的，尽管不寻常的交易行为和真正的异常，这些异常可能表明欺诈活动，如洗钱，网络钓鱼或利用合同漏洞。\n除了识别潜在的欺诈交易外，LLM还有助于风险评估和监管合规。通过根据当前的合规标准和风险模型分析交易数据，法学硕士可以帮助金融机构管理其风险敞口，并遵守反洗钱（AML）和了解客户（KYC）法规。它们复杂的分析功能可以为合规官员和监管机构提供有价值的见解，允许采用更主动的方法来检测和预防金融犯罪。\n总之，LLM在区块链交易分析中的应用反映了对加强数字金融系统安全措施的承诺。通过将深度学习算法与广泛的交易数据集相结合，llm成为一道强大的防线，不仅能够实时识别异常活动，还能够随着威胁的发展而发展，确保管理基于区块链的交易的弹性和安全框架。\n\n3.3. LLM作为智能合约的Fuzzer大型语言模型（llm）已被越来越多地用于提升模糊化过程，特别是在智能合约安全分析领域，如LLM4FUZZ[55]、ACFIX[56]和Sun等。表4中的方法涉及利用llm来准确评估智能合约中特定代码区域的复杂性和漏洞可能性。因此，这些指标用于指导模糊测试者的方向和焦点，将他们引导到更有可能包含潜在安全威胁的代码段。\nllm应用于模糊测试练习，通过缩小模糊测试通常导航的巨大状态空间，显著提高了这些操作的效率。这种精确定位的模糊方法有助于提高覆盖率，并比传统工具揭示更多漏洞，特别是那些与传统方法可能忽略的智能合约代码的复杂性质有关的漏洞.\n此外，这种改进的模糊测试技术允许集成用户定义的不变量和手动插入的断言，以便在模糊测试期间监视和管理状态。这种方法可以减少勘探开销，并改进对常规模糊例程可能错过的更深刻逻辑问题的检测。在现实世界的去中心化金融（DeFi）项目中，对这种llm增强模糊方法的评估已经证明了它的有效性，优于基线模糊参数，并发现了重大漏洞。这些漏洞如果不被发现和利用，可能会造成重大的经济损失。\n总之，将llm融合到模糊工作流程中，为智能合约的自动安全分析所面临的挑战提供了一个有前途的智能解决方案，强调了它们增加基于区块链平台稳健性的潜力。\n\n3.4 LLM作为智能合约的开发人员表5中最近的研究，如Storhaug等人的[29]、karanjai等人的[33]、Petrovic等人的[61]、Zhao等人的[62]、Haque等人的[63]、MazzumaGPT[58]、Du等人的[59]和GPTutor[60]，已经开始考察ChatGPT和谷歌Palm2等大型语言模型（llm）在自动生成智能合约中的有效性和可靠性。这些智能合约是区块链生态系统不可或缺的一部分，无需中介即可执行协议，其准确性和安全性至关重要。该研究主要构建了一个测试框架，从多个方面评估智能合约，即有效性、正确性、效率、安全性和可维护性.\n这些结果表明，尽管llm在理解合同条款和生成语法正确的Solidity代码方面表现得很熟练，但通常生成的合同存在相当大的安全漏洞。这个发现表明了代码运行质量中的一个关键问题。评估表明，虽然LLM可以简化合同创建过程，但如果不进行彻底审查，生成的代码可能会被利用，这是一个潜在的风险。\n重要的是，这些研究强调了有效的提示工程的作用。结果表明，LLM的产出受到提示的特异性和清晰度的显著影响，必须精心设计提示，以尽量减少产生歧义或有缺陷的代码的风险。这尤其具有挑战性，因为生成智能合约需要精度，并且模型必须正确解释和应用法律术语的语义。\n这些工作指出了综合分析以及LLM所采用的方法的改进的重要性。人们乐观地认为，LLM的未来迭代，通过更好的培训和及时的设计考虑，可以提高人工智能生成的智能合约的质量和安全性。它还暗示了这些工具通过减少所需的时间和精力来彻底改变合同生成的潜力，同时也表明了对更强大的安全措施和测试方法的迫切需求。\n\n这样的研究分析为智能合约生成中LLM应用的现状提供了一个总体视图。这些发现是对过度依赖人工智能而没有进行充分检查的警示，但也为未来的进步制定了路线图，可以负责任地利用人工智能的全部潜力。\n3.5. LLM作为加密货币社区的参与者大型语言模型（llm），如GPT-3.5和ChatGPT，正在成为加密货币社区的强大工具，如Trozze等人[64]，Axelsen等人[65]，Liu等人[66]，Ziegler等人[67]和GPTutor[68]，尽管它们各自具有优势和劣势。表6中的相关作品共同描绘了LLM在高风险、高度不稳定的加密货币领域内变革治理和法律流程的潜力。\n治理成为一个主要主题，因为LLM可以为这个基本上不受监管的领域的结构和透明度做出重大贡献。第一份文件概述了人工智能系统面临的更广泛的治理挑战，建议区块链作为引入可验证性和问责制的可行解决方案。另一方面，LLM在捕捉法律推理的复杂性方面的局限性得到了强调，这一问题在三个研究中得到了不同程度的回应。\n这些模式在法律环境中的实际应用，特别是在第二和第三个文件中详细说明，强调了它们在起草法律申诉中的创新作用。这一发展为与加密货币法规和诉讼相关的法律工作未来带来了希望，因为它表明LLM可以减轻人类专家的一些工作量，尽管仍然需要人类监督。\n\n虽然治理和法律援助主导了话语，但在整个文本中都有一种谨慎乐观的基调。人们认识到LLM在加密货币领域的变革潜力，但也明确认识到人工智能技术需要进一步发展，以充分融入复杂的决策过程，其中法律和道德考虑至关重要。\n从本质上讲，这三份文件的集体叙述集中在一个前提上，即LLM对加密货币社区的治理和法律部门具有变革潜力，但必须克服理解上的挑战，才能完全信任他们的自治角色.\n3.6. 杂项如表7所示，LLM还应用于其他bb0安全领域，包括智能合约编译器[69]、零知识证明[70]、模型训练[22,71]、NFT生成[72]。我们将在以后详细介绍它们的应用。\n\n4 LLM4BS的案例研究在本节中，我们将通过三个不同的案例研究进行深入研究，每个案例研究都有助于说明和阐明区块链系统（LLM4BS）的大型语言模型的各种具体应用。表8中的这些案例经过精心挑选，涵盖了广泛的场景，包括LLM4FUZZ[55]§4.1、SMARTINV[31]§4.2、BLOCKGPT [28]\n4.1. LLM4Fuzz如图4所示，LLM4FUZZ[55]是网络安全领域的一项创新技术，特别是在区块链网络中的智能合约安全领域。它将大型语言模型（llm）的强大功能与模糊测试方法复杂地结合在一起，主动发现可能危及智能合约完整性的漏洞。\nLLM是高度复杂的人工智能模型，在理解和生成类似人类的文本方面取得了重大进展，最近，它们已被证明善于理解编程语言和代码结构。LLM4FUZZ通过部署llm来智能地指导模糊测试过程，从而利用了这种能力。这导致对智能合约进行更深刻和细致的探索，将测试工作集中在法学硕士认为最有可能包含安全漏洞的领域。通过这样做，LLM4FUZZ不仅成功地简化了异常检测过程，而且提高了其准确性和深度。\n在区块链技术的世界里，智能合约作为不可变的协议，根据编码条件自动执行，安全漏洞的潜在负面影响就会加剧。智能合约控制着重要的数字资产，对分布式应用程序（dApps）的功能至关重要。区块链的不可变特性增加了一层复杂性，因为部署的智能合约一旦提交给区块链，就无法更改。因此，先发制人的安全保证对于确保它们的可靠性和保护它们所管理的资产和过程变得至关重要。\nLLM4FUZZ通过识别和确定智能合约代码中潜在问题区域的优先级，提供了一种新颖的安全分析层。这种优先级是通过LLM对历史上或通常与漏洞相关的代码模式的学习理解来实现的.该方法增强了传统的模糊测试策略，传统的模糊测试策略通常采用一种更散弹枪的方法，即用随机数据输入轰击代码。LLM4FUZZ的目标测试不仅更高效，而且在发现可能被遗漏的复杂漏洞方面也更有效。\n\n在实现之后，LLM4FUZZ已经针对现有的模糊测试技术进行了基准测试，并始终表现出卓越的性能。它加快了漏洞检测过程，增加了可以检测到的安全缺陷的广度，从而加强了整体安全态势。\nLLM4FUZZ的案例象征着将人工智能整合到网络安全制度中的远见。它概括了人工智能对改进和重新定义现有技术流程的变革性影响，特别是在对蓬勃发展的数字经济至关重要的领域。通过它的镜头，我们瞥见了智能合约安全的未来——人工智能驱动的工具不仅可以预测，还可以积极参与对抗网络威胁的持续战斗。\n4.2. SMARTINV为了提高区块链智能合约的可靠性和安全性，SMARTINV[31]代表了该领域的重大突破。它的主要功能是推断智能合约中的不变量，这可以在自动化识别难以捉摸的错误的过程中不可或缺，这些错误通常会避开传统的机器审计方法。图5显示了SMARTINV的架构。\nSMARTINV的独特之处在于它的多模式学习策略，它承认真正理解智能合约的操作行为需要一个多方面的方法——一个结合和分析不同类型的信息或模式的方法。SMARTINV特别利用了智能合约中的静态代码和动态交易数据。通过将代码模式与事务行为相关联，SMARTINV准备揭示指向智能合约在其整个生命周期中的预期和预期状态的不变条件。这种整体方法确保对可能导致未来漏洞和利用的潜在安全弱点进行更彻底的检查和更高的检测率。\n\n该框架运行的前提是，没有单一的信息模式可以完全表达智能合约的复杂逻辑和潜在的边缘情况。因此，通过融合多个数据源，SMARTINV可以更准确地描述智能合约的功能，从而显着减少误报和更精确的错误检测。这种集成的智能合约分析方法促进了其部署和操作的更大保证，这在安全性和信任至关重要的区块链应用程序中是一个关键问题。\n在部署SMARTINV时，研究人员通过对一系列智能合约进行测试来证明其有效性，它不仅显示出高度的准确性，而且在可扩展性方面也表现出令人印象深刻的能力。SMARTINV成为智能合约开发和审计领域的宝贵资产，为未来的方法树立了先例，以其多模态分析框架为基础，在不断发展的区块链技术领域增强安全措施。\n\n4.3. BLOCKGPT如图6所示，BLOCKGPT[28]作为区块链安全领域的典范转变，作为最先进的入侵检测系统（IDS），专门用于抵消和识别区块链网络中的潜在恶意交易。IDS以高度复杂的大型语言模型为基础，该模型经过了来自以太坊区块链的大量交易数据的精心训练，以太坊区块链是业内使用最广泛的平台之一。\nBLOCKGPT的创新之处在于，它脱离了传统的主要依赖于预定规则或已知模式的检测方法。相反，BLOCKGPT采用了一种主动的、基于学习的方法，使其能够识别一系列异常情况，包括可以绕过传统基于规则的系统的复杂和以前未见过的威胁。\nBLOCKGPT在测试场景中取得了巨大的成功，证明了其检测能力的强大。它熟练地识别并适当地将124个经过验证的攻击交易中的49个排在各自受害者合同中发生的最不正常的三个交易中。这种高精确度表明该系统的精确异常识别算法，表明区块链的IDS领域取得了实质性进展。\n除了检测精度之外，BLOCKGPT的效率还体现在其处理速度上，平均每秒处理2,284笔交易，偏差相对较小。这种能力不仅是理论上的，而且表明系统已经准备好部署在实时监控和响应的现实区块链环境中至关重要的。\nBLOCKGPT的适应性扩展到各种区块链架构和应用，从金融到智能合约。这种多功能性与其实时处理能力相结合，提供了一个强大且可扩展的解决方案，可以无缝集成到现有区块链基础设施中，以增强其抵御各种安全威胁的弹性\n随着区块链技术继续融入数字交易和智能合约部署的结构，BLOCKGPT等系统代表了保护这些平台的重要组成部分。随着BLOCKGPT所基于的机器学习模型的采用，b区块链IDS的未来似乎越来越安全，为更安全、更可靠的区块链操作铺平了道路。\n5 LLM4BS任务的未来方向与挑战在深入研究区块链安全的大型语言模型（LLM4BS）的未来时，学术界与一系列关键的焦点领域进行了竞争，这些领域需要协调一致的学术努力来解决固有的挑战并扩展LLM在区块链系统中的实用性。为了反映这一研究领域固有的细微差别和复杂性，本文阐述了以下重点：\n跨学科关系：不可否认，LLM4BS下一阶段的本质是基于人工智能、网络保护机制和分布式账本技术领域之间的协调相互作用[136,137,13]。这种跨学科合作不仅是叠加的，而且是协同的，因为它利用了每个学科的优势和见解，形成了抵御网络仇恨的强大屏障。学术界和工业界都在呼吁建立一个强大的联盟，强调认知计算与加密弹性和分散架构的融合可以导致区块链网络安全的范式转变。\n监管和合规挑战：监管框架的变化不仅要求合规，还要求LLM4BS领域的学者和从业者积极参与监管机构[5,138]。这种关系是相互的；随着监管机构对将人工智能集成到b区块链的影响有了更深入的了解，这一领域的参与者有责任倡导鼓励创新的法规，同时保持强大的安全措施。尖端技术和监管之间的动态相互作用是一种微妙的平衡，为区块链安全解决方案的增长和适应提供了一个稳定而灵活的平台。\n动态安全威胁：网络威胁范围类似于嵌合兽——不断变异并呈现不可预见的挑战[18,139]。像LLM4BS这样的安全模型必须具有固有的可塑性，允许它们与它们所要对抗的威胁一起发展。LLM与区块链安全的整合不是一种静态的解决方案，而是一种不断适应的保障措施，需要一种广泛的网络安全方法，以应对复杂网络攻击的扩散以及目标破坏的微妙之处。保持b区块链事务的完整性取决于先发制人地识别和消除这些多变的威胁\n道德治理和偏见缓解：LLM4BS运作的道德毯是丰富而复杂的，要求对可能无意中传播偏见或不公平结果的安全实践进行认真的检查和解决[144,141]。对公平算法的追求超越了技术领域，涉及到技术部署的社会文化动态和道德层面。因此，超越统计偏见的研究，涉及哲学、社会学和伦理学，共同努力对于营造一种氛围至关重要，在这种氛围中，人工智能不仅可以加强安全，还可以以对正义和公平的潜在承诺为基础。\n能源考虑和人工智能可持续性：在解决区块链运营的碳足迹问题时，还迫切需要面对训练和部署大型语言模型的能源密集型特性[142,143,144]。这些人工智能系统的生态影响需要双重战略：提高算法效率以减少计算负荷，并探索可以可持续地为这些活动提供动力的替代能源。在LLM4BS应用中对生态和谐的追求必须反映出区块链技术各方面对可持续性的更广泛承诺，确保安全能力的加速不会以不可持续的环境成本为代价。\n人工智能中的伦理考虑：在LLM4BS实施的轨迹中，伦理的作用不能被夸大，因为它支撑着人工智能应用的各个方面——从数据来源到算法的透明度，再到人工智能或借助人工智能做出的决策的问责制。为LLM4BS实施一个强有力的道德框架需要一个深刻的拷问指导人工智能开发的原则，鼓励渗透到模型设计、部署和监控的每一层的审查。因此，创造一种环境，在这种环境中，对人工智能驱动的安全措施的信任不仅是假设，而且是通过负责任的做法精心培养的。\n数据质量和访问：健壮的LLM4BS部署的核心是数据的基本元素——它的口径、范围和提供给它的可访问性。这里存在着挑战：构建和维护数据库，这些数据库不仅要全面和具有代表性，而且要着眼于提高大型语言模型在检测异常和加强区块链事务中的安全参数方面的有效性。这项任务扩展到制定协议，以确保数据完整性和符合道德标准的采购，从而维护这些人工智能系统的神圣性和可靠性。解决这些问题需要一种战略性的、方法学的方法来充分利用LLM4BS的潜力。这包括对正在进行的研究的承诺，严格的道德审查，以及与技术和监管环境同步发展的协同努力。对这些要点有了基本的了解，社区就能更好地为LLM4BS增强b区块链安全措施的弹性和效率铺平道路。\n6 总结总之，我们对将大型语言模型（llm）集成到区块链安全中的回顾突出了LLM4BS组合所带来的技术进步和复杂挑战。llm在区块链中增强安全协议的潜力是显而易见的，为智能合约、异常交易检测和加密货币社区发展提供了创新的解决方案。然而，要实现这一潜力，需要对可扩展性、隐私、不断发展的网络威胁以及人工智能的伦理影响保持警惕。LLM在区块链安全领域的成功不仅取决于持续的技术改进，还取决于道德实践、监管一致性和知情的社区参与。LLM与区块链安全的整合标志着一个变革的时代，需要一种协作的方式，平衡创新与审慎的监督，以建立一个有弹性和公平的安全未来。\n","tags":["智能合约论文"]}]