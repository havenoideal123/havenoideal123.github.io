[{"title":"helloworld.md","url":"/2025/10/30/helloworld-md/","content":""},{"title":"小型内核加载程序.md","url":"/2025/11/06/%E5%B0%8F%E5%9E%8B%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F-md/","content":"李忠老师书中15章的内容，浅读时觉得十分困难乏味，如今按照先看懂代码再看书理解思路的方式，将整个代码进行了手敲，感受颇多，也体会到了李忠老师深厚的汇编功底。\n整个代码分为三个部分\n\n主引导代码：负责设置GDT和加载内核代码\n内核代码：负责用户程序的加载\n用户程序：读取一个扇区中的内容并显示\n\n再次建议大家自己手敲一遍代码，理解程度绝非是直接看书能够比拟的。许多难以理解的代码李忠老师均已作出解答。\n主引导区代码\n;主引导分区的代码，主要用于加载内核core_base_address equ 0x00040000 ;定义常数，内核加载的起始位置core_start_sector equ 0x00000001 ;开始的逻辑扇区，用工具先把内核写在1扇区;常规设置套路;初始化堆栈mov ax,csmov ss,axmov sp,0x7c00;计算GDT逻辑地址mov eax,[cs:pgdt+ 0x7c00 + 0x02] ;GDT的物理地址xor edx,edx ;清零mov ebx,16div ebx ;商在eax里，余数在edxmov ds,eax ;指向GDTmov ebx,edx ;偏移;创建0号描述符可以跳过;创建1，数据段，对应0-4GB空间mov dword [ebx + 0x08],0x0000ffff ; 段界限为0xffffmov dword [ebx + 0x0c],0x00cf9200 ; 粒度4kB，;创建2，代码段，mov dword [ebx + 0x10],0x7c0001ff ; 基地址是0x7c00，界限0x1ff，代码是从7c00开始的mov dword [ebx + 0x14],0x00409800 ; 粒度为1字节;创建3，堆栈段mov dword [ebx + 0x18],0x7c00fffe ; 基地址7c00，界限0xFFFE，另名代码段mov dword [ebx + 0x1c],0x00cf9600 ; 粒度4KB;创建4，显示缓冲区mov dword [ebx + 0x20],0x80007fff ; 基地址B800，界限0x7fffmov dword [ebx + 0x24],0x0040920b ; 粒度为1字节;初始化GFDTRmov word [cs:pgdt+0x7c00],39 ; 描述符界限lgdt [cs:pgdt+0x7c00] ;我们代码运行在7c00处，pgdt拿到的是相对7c00的偏移量;其他工作 打开A20in al,0x92or al,0000_0010Bout 0x92,al;打开开关cli ;关闭中断mov eax,cr0or eax,1mov cr0,eax ;进入保护模式jmp 0x0010:flush ;0x0010是选择子代码段，这里是因为当前主引导就已经在7c00了[bits 32]flush:  ;初始化数据段和堆栈  mov eax,0x0008 ;选择子-&gt;0000000000001000 -数据段  mov ds,eax  mov eax,0x0018 ;堆栈段  mov ss,eax  xor esp,esp   ;加载系统核心程序  mov edi,core_base_address  mov eax,core_start_sector  mov ebx,edi  call read_hard_disk_0 ;从指定的扇区中读写数据到指定位置  ;判断核心程序的大小  mov eax,[edi] ;核心程序的尺寸  xor edx,edx  mov ecx,512  div ecx ;每个扇区为512字节，所以除以512  or edx,edx  jnz @1 ;判断余数是否为0，不为0，则说明还有扇区没有读完  dec eax ;这里保存着除数，除数为核心程序大小的扇区数，因为前面已经读了一个扇区了，所以减一@1:  or eax,eax ; 考虑程序&lt;=512的情况，就只有一个扇区  jz setup  ;如果还有  mov ecx,eax  mov eax,core_start_sector  inc eax ;从下一个扇区开始读@2:  call read_hard_disk_0  inc eax  loop @2 ;此时这里的ecx就是所有的扇区数量，读完为止setup:  mov esi,[pgdt+0x7c00+0x02]  ;创建公用例程描述符  mov eax,[edi+0x04] ;公共例程段的偏移，在core中定义的  mov ebx,[edi+0x08]; 核心数据段偏移  sub ebx,eax  dec ebx ;公共例程段界限 （代码量-1）  add eax,edi ;公共例程段的基地址4000+相对偏移  mov ecx,0x00409800 ;代码段描述符  call make_gdt_descriptor  mov [esi+0x028],eax  mov [esi+0x02c],edx  ;建立核心数据段描述符  mov eax,[edi+0x08]                 ;核心数据段起始汇编地址  mov ebx,[edi+0x0c]                 ;核心代码段汇编地址   sub ebx,eax  dec ebx                            ;核心数据段界限  add eax,edi                        ;核心数据段基地址  mov ecx,0x00409200                 ;字节粒度的数据段描述符   call make_gdt_descriptor  mov [esi+0x30],eax  mov [esi+0x34],edx   ;建立核心代码段描述符  mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址  mov ebx,[edi+0x00]                 ;程序总长度  sub ebx,eax  dec ebx                            ;核心代码段界限  add eax,edi                        ;核心代码段基地址  mov ecx,0x00409800                 ;字节粒度的代码段描述符  call make_gdt_descriptor  mov [esi+0x38],eax  mov [esi+0x3c],edx  mov word [pgdt+0x7c00],63 ;添加了内核描述符，更新GDT  lgdt [pgdt+0x7c00]  ;至此内核程序加载全部完成，正式进入内核段进行执行  jmp far [edi+0x10] ;edi+0x10是内核入口偏移，core中定义;=============================================================================make_gdt_descriptor:  ;构造描述符，eax：基地址，ebx：段界限，ecx：属性。返回一个完整的描述符  ;前32位  mov edx,eax  sh1 eax,16 ;左移16位，保留低16位的基地址  or ax,bx ;将bx中的段界限放入低16位  and edx,0xffff0000 ;清除低16位  rol edx,8 ;循环左移8位，重新排列  bswap edx ;字节交换  xor bx,bx ;清零  or edx,ebx   or edx,ecx  ret;=============================================================================read_hard_disk_0:  ;负责从硬盘读一个逻辑扇区，eax为扇区号，ds:ebx为目标地址  push eax  push ecx  push edx  push eax  ;读取扇区数1  mov dx,0x1f2  mov al,1  out dx,al  ;发送逻辑扇区号32位，进行拆分发送  inc dx ;0x1f3  pop eax  out dx,al  inc dx ;0x1f4  mov cl,8  shr eax,cl  out dx,al  inc dx ;0x1f5  shr eax,cl  out dx,al   inc dx ;0x1f6  shr eax,cl  or al,0xe0  out dx,al  inc dx ;0x1f7  mov al,0x20 ;读命令  out dx,al.waits:  in al,dx ;从dx中读状态给ax  and al,0x88 ;只关注7.3号位  cmp al,0x88 ;都为1则处理完成  jnz .waits  mov ecx,256 ;总共读256个字  mov dx,0x1f0 .readw:  in ax,dx ;从0x1f0中读一个字给ax  mov [ebx],ax  add ebx,2  loop .readw  ;读写完成  pop edx  pop ecx  pop eax  ret;============================================================================pgdt: dw 0  dd 0x00007e00 ;GDT物理地址\n\n内核代码：\n;-------------------------------------------------------------------------------         ;以下常量定义部分。内核的大部分内容都应当固定                ;!!!!注意常量的定义并不占内存空间，也就是说实际的开始地址依然是下面的core_length         core_code_seg_sel     equ  0x38    ;内核代码段选择子         core_data_seg_sel     equ  0x30    ;内核数据段选择子          sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子          video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子         core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子         mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子;-------------------------------------------------------------------------------         ;以下是系统核心的头部，用于加载核心程序          core_length      dd core_end       ;核心程序总长度#00         sys_routine_seg  dd section.sys_routine.start                                            ;系统公用例程段位置#04         core_data_seg    dd section.core_data.start                                            ;核心数据段位置#08         core_code_seg    dd section.core_code.start                                            ;核心代码段位置#0c         core_entry       dd start          ;核心代码段入口点#10                          dw core_code_seg_sel;================================================================================[bits 32];=================================================================================SECTION sys_routine vstart=0 ;公共例程段;字符串显示put_string:  push ecx  .getc:  mov cl,[ebx] ;要显示的字符   or cl,cl ;判断是否为0  jz .exit  call put_char  inc ebx  jmp .getc  .exit:  pop ecx  retf ;段间返回 ;================================================================================ put_char:                                   ;在当前光标处显示一个字符,并推进                                            ;光标。仅用于段内调用                                             ;输入：CL=字符ASCII码          pushad         ;以下取当前光标位置         mov dx,0x3d4         mov al,0x0e         out dx,al         inc dx                             ;0x3d5         in al,dx                           ;高字         mov ah,al         dec dx                             ;0x3d4         mov al,0x0f         out dx,al         inc dx                             ;0x3d5         in al,dx                           ;低字         mov bx,ax                          ;BX=代表光标位置的16位数         cmp cl,0x0d                        ;回车符？         jnz .put_0a         mov ax,bx         mov bl,80         div bl         mul bl         mov bx,ax         jmp .set_cursor  .put_0a:         cmp cl,0x0a                        ;换行符？         jnz .put_other         add bx,80         jmp .roll_screen  .put_other:                               ;正常显示字符         push es         mov eax,video_ram_seg_sel          ;0xb8000段的选择子         mov es,eax         shl bx,1         mov [es:bx],cl         pop es         ;以下将光标位置推进一个字符         shr bx,1         inc bx  .roll_screen:         cmp bx,2000                        ;光标超出屏幕？滚屏         jl .set_cursor         push bx                            ;为了修改原书程序的逻辑问题，新增         push ds         push es         mov eax,video_ram_seg_sel         mov ds,eax         mov es,eax         cld         mov esi,0xa0                       ;小心！32位模式下movsb/w/d          mov edi,0x00                       ;使用的是esi/edi/ecx          mov ecx,1920         rep movsw         mov bx,3840                        ;清除屏幕最底一行         mov ecx,80                         ;32位程序应该使用ECX  .cls:         mov word[es:bx],0x0720         add bx,2         loop .cls         pop es         pop ds         ;mov bx,1920                       ;为了修改原书程序的逻辑问题，删除         pop bx                             ;为了修改原书程序的逻辑问题，新增         sub bx,80                          ;为了修改原书程序的逻辑问题，新增  .set_cursor:         mov dx,0x3d4         mov al,0x0e         out dx,al         inc dx                             ;0x3d5         mov al,bh         out dx,al         dec dx                             ;0x3d4         mov al,0x0f         out dx,al         inc dx                             ;0x3d5         mov al,bl         out dx,al         popad         ret                          ;================================================================================read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区                                            ;EAX=逻辑扇区号                                            ;DS:EBX=目标缓冲区地址                                            ;返回：EBX=EBX+512         push eax          push ecx         push edx           push eax            mov dx,0x1f2         mov al,1         out dx,al                          ;读取的扇区数         inc dx                             ;0x1f3         pop eax         out dx,al                          ;LBA地址7~0         inc dx                             ;0x1f4         mov cl,8         shr eax,cl         out dx,al                          ;LBA地址15~8         inc dx                             ;0x1f5         shr eax,cl         out dx,al                          ;LBA地址23~16         inc dx                             ;0x1f6         shr eax,cl         or al,0xe0                         ;第一硬盘  LBA地址27~24         out dx,al         inc dx                             ;0x1f7         mov al,0x20                        ;读命令         out dx,al  .waits:         in al,dx         and al,0x88         cmp al,0x08         jnz .waits                         ;不忙，且硬盘已准备好数据传输          mov ecx,256                        ;总共要读取的字数         mov dx,0x1f0  .readw:         in ax,dx         mov [ebx],ax         add ebx,2         loop .readw         pop edx         pop ecx         pop eax           retf                               ;段间返回 allocate_memory:  ;分配内存，ecx为分配的字节数，输出ecx为起始位置  push ds  push eax  push ebx  mov eax,core_data_seg_sel ;ds指向数据段  mov ds,eax  ;定位到要分配的物理地址  mov eax,[ram_alloc] ;起始地址   add eax,ecx ;分配完成的地址  mov ecx, [ram_alloc] ;这里已经是本次分配得到的位置  mov ebx,eax  and ebx,0xfffffffc  add ebx,4 ;数据对齐  test eax,0x00000003 ;判断是否已经对齐  cmovnz eax,ebx  mov [ram_alloc],eax ;这里存的是下次请求分配时的位置  pop ebx  pop eax  pop ds  retf;================================================================================set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符                                            ;输入：EDX:EAX=描述符                                             ;输出：CX=描述符的选择子         push eax         push ebx         push edx           push ds         push es           mov ebx,core_data_seg_sel          ;切换到核心数据段         mov ds,ebx         sgdt [pgdt]                        ;以便开始处理GDT         mov ebx,mem_0_4_gb_seg_sel         mov es,ebx         movzx ebx,word [pgdt]              ;GDT界限          inc bx                             ;GDT总字节数，也是下一个描述符偏移          add ebx,[pgdt+2]                   ;下一个描述符的线性地址            mov [es:ebx],eax         mov [es:ebx+4],edx           add word [pgdt],8                  ;增加一个描述符的大小              lgdt [pgdt]                        ;对GDT的更改生效             mov ax,[pgdt]                      ;得到GDT界限值         xor dx,dx         mov bx,8         div bx                             ;除以8，去掉余数         mov cx,ax                             shl cx,3                           ;将索引号移到正确位置          pop es         pop ds         pop edx         pop ebx         pop eax           retf ;-------------------------------------------------------------------------------make_seg_descriptor:                        ;构造存储器和系统的段描述符                                            ;输入：EAX=线性基地址                                            ;      EBX=段界限                                            ;      ECX=属性。各属性位都在原始                                            ;          位置，无关的位清零                                             ;返回：EDX:EAX=描述符         mov edx,eax         shl eax,16         or ax,bx                           ;描述符前32位(EAX)构造完毕         and edx,0xffff0000                 ;清除基地址中无关的位         rol edx,8         bswap edx                          ;装配基址的31~24和23~16  (80486+)         xor bx,bx         or edx,ebx                         ;装配段界限的高4位         or edx,ecx                         ;装配属性         retf;-------------------------------------------------------------------------------;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助put_hex_dword:                              ;在当前光标处以十六进制形式显示                                            ;一个双字并推进光标                                            ;输入：EDX=要转换并显示的数字                                            ;输出：无         pushad         push ds         mov ax,core_data_seg_sel           ;切换到核心数据段         mov ds,ax         mov ebx,bin_hex                    ;指向核心数据段内的转换表         mov ecx,8  .xlt:         rol edx,4         mov eax,edx         and eax,0x0000000f         xlat         push ecx         mov cl,al         call put_char         pop ecx         loop .xlt         pop ds         popad         retf;=================================================================================SECTION code_data vstart=0 ;核心数据段  pgdt             dw  0             ;用于设置和修改GDT                   dd  0  ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址  ;符号地址检索表  salt:  ;这里表示着对应的符号名称，例如@PrintString，表示着在程序中调用的函数名，但实际对应的是put_string方法  ;同理，@ReadDiskData，表示着在程序中调用的函数名，但实际对应的是read_hard_disk_0方法    ;用户程序加载的时候内核的任务是对比这两张salt表，将哦那个户程序salt表中的符号名切换为相应的入口地址        salt_1           db  &#x27;@PrintString&#x27;              times 256-($-salt_1) db 0                  dd  put_string                  dw  sys_routine_seg_sel  salt_2           db  &#x27;@ReadDiskData&#x27;              times 256-($-salt_2) db 0                  dd  read_hard_disk_0                  dw  sys_routine_seg_sel  salt_3           db  &#x27;@PrintDwordAsHexString&#x27;              times 256-($-salt_3) db 0                  dd  put_hex_dword                  dw  sys_routine_seg_sel  salt_4           db  &#x27;@TerminateProgram&#x27;              times 256-($-salt_4) db 0                  dd  return_point                  dw  core_code_seg_sel  salt_item_len   equ $-salt_4  salt_items      equ ($-salt)/salt_item_len  message_1        db  &#x27;  If you seen this message,that means we &#x27;                  db  &#x27;are now in protect mode,and the system &#x27;                  db  &#x27;core is loaded,and the video display &#x27;                  db  &#x27;routine works perfectly.&#x27;,0x0d,0x0a,0  message_5        db  &#x27;  Loading user program...&#x27;,0    do_status        db  &#x27;Done.&#x27;,0x0d,0x0a,0    message_6        db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a                  db  &#x27;  User program terminated,control returned.&#x27;,0  bin_hex          db &#x27;0123456789ABCDEF&#x27;                                    ;put_hex_dword子过程用的查找表  core_buf   times 2048 db 0         ;内核用的缓冲区  esp_pointer      dd 0              ;内核用来临时保存自己的栈指针     cpu_brnd0        db 0x0d,0x0a,&#x27;  &#x27;,0  cpu_brand  times 49 db 0  cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0;================================================================================SECTION core_code vstart=0 ;核心代码段;加载并重定位用户程序;esi 起始逻辑扇区号，返回ax：用户程序头部选择子load_relocate_program:  push ebx  push ecx  push edx  push esi  push edi  push ds  push es   mov eax,core_data_seg_sel ;指向内核数据段  mov ds,eax   mov eax,esi  mov ebx,core_buf  call sys_routine_seg_sel:read_hard_disk_0 ;将在50号逻辑扇区的用户程序复制到core_buf缓冲区    ;复制完成后  ;判断程序大小  mov eax,[core_buf] ; 这里的理由和前面一样，定义的时候就是放在第一行的  mov ebx,eax  and ebx,0xfffffe00 ;清除低9位，等于➗512并取整  add ebx,512 ;补齐512  test eax,0x000001ff ;检查低9位是否为0  cmovnz eax,ebx ;不为0就将对齐后的设为eax，cmovnz : 如果为非零则将源数据复制给目标数据  ;此时已经获取了程序大小在eax中，请求分配内存空间  mov ecx,eax  call sys_routine_seg_sel:allocate_memory  ;分配后ecx保存了分配的起始地址  mov ebx,ecx                   push ebx                       xor edx,edx  mov ecx,512  div ecx  mov ecx,eax ;总扇区数  ;切换ds到0-4GB的段，好加载用户程序  mov eax,mem_0_4_gb_seg_sel  mov ds,eax    mov eax,esi ;起始扇区号.b1:  call sys_routine_seg_sel:read_hard_disk_0 ;老规矩读扇区  inc eax  loop .b1  ;读完整个用户程序的扇区  ;和之前一样，创建程序的头部描述符、代码描述符等  pop edi                            ;恢复程序装载的首地址   mov eax,edi                        ;程序头部起始线性地址  mov ebx,[edi+0x04]                 ;段长度  dec ebx                            ;段界限   mov ecx,0x00409200                 ;字节粒度的数据段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x04],cx               ;建立程序代码段描述符  mov eax,edi  add eax,[edi+0x0c]                 ;代码起始线性地址  mov ebx,[edi+0x10]                 ;段长度  dec ebx                            ;段界限  mov ecx,0x00409800                 ;字节粒度的代码段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x0c],cx  ;建立程序数据段描述符  mov eax,edi  add eax,[edi+0x14]                 ;数据段起始线性地址  mov ebx,[edi+0x18]                 ;段长度  dec ebx                            ;段界限  mov ecx,0x00409200                 ;字节粒度的数据段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x14],cx  ;建立程序堆栈段描述符  mov eax,edi  add eax,[edi+0x1c]                 ;数据段起始线性地址  mov ebx,[edi+0x20]                 ;段长度  dec ebx                            ;段界限  mov ecx,0x00409200                 ;字节粒度的数据段描述符  call sys_routine_seg_sel:make_seg_descriptor  call sys_routine_seg_sel:set_up_gdt_descriptor  mov [edi+0x1c],cx  ;重定位SALT  ;用ds:esi指向内核-salt，es：edi指向用户的salt  mov eax,[edi+0x04]  mov es,eax     ;es指向程序头部              mov eax,core_data_seg_sel  mov ds,eax  ;ds指向内核数据段  cld ;修改df，使得cmps按正向比较  mov ecx,[es:0x24] ;用户程序salt的条目数  mov edi,0x28  ;用户salt的位置.b2:  push ecx  push edi    mov ecx,salt_items  mov esi,salt.b3:  push edi   push esi  push ecx  mov ecx,64  repe cmpsd ;重复比较双字，当不匹配或者计数器为0时停止  jnz .b4  mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据  mov [es:edi-256],eax               ;将字符串改写成偏移地址  mov ax,[esi+4]  mov [es:edi-252],ax                ;以及段选择子.b4:  pop ecx  pop esi  add esi,salt_item_len  pop edi                            ;从头比较  loop .b3  pop edi  add edi,256  pop ecx  loop .b2  mov ax,[es:0x04] ;返回用户程序头部段的段选择子  pop es                             ;恢复到调用此过程前的es段   pop ds                             ;恢复到调用此过程前的ds段  pop edi  pop esi  pop edx  pop ecx  pop ebx  ret  ;-------------------------------------------------------------------------------start:  mov ecx,core_data_seg_sel ;指向核心数据段  mov ds,ecx  mov ebx,message_1  call sys_routine_seg_sel:put_string ;显示了message_1的内容  ;显示处理器的品牌信息  mov eax,0x80000002  cpuid  mov [cpu_brand + 0x00],eax  mov [cpu_brand + 0x04],ebx  mov [cpu_brand + 0x08],ecx  mov [cpu_brand + 0x0c],edx  mov eax,0x80000003  cpuid  mov [cpu_brand + 0x10],eax  mov [cpu_brand + 0x14],ebx  mov [cpu_brand + 0x18],ecx  mov [cpu_brand + 0x1c],edx  mov eax,0x80000004  cpuid  mov [cpu_brand + 0x20],eax  mov [cpu_brand + 0x24],ebx  mov [cpu_brand + 0x28],ecx  mov [cpu_brand + 0x2c],edx  mov ebx,cpu_brnd0  call sys_routine_seg_sel:put_string  mov ebx,cpu_brand  call sys_routine_seg_sel:put_string  mov ebx,cpu_brnd1  call sys_routine_seg_sel:put_string  mov ebx,message_5  call sys_routine_seg_sel:put_string  mov esi,50 ;用户程序位于50号逻辑扇区  call load_relocate_program  ;此时用户程序已经完成加载和符号表的重定向  mov ebx,do_status  call sys_routine_seg_sel:put_string    mov [esp_pointer],esp ;临时保存堆栈指针  mov ds,ax ;ds指向用户程序头部段  jmp far [0x08] ;0x08是用户程序头部选择子  return_point:  ;从用户程序返回控制权给内核  ;指向内核数据段  mov eax,core_data_seg_sel  mov ds,eax  ;指向内核堆栈段  mov eax,core_stack_seg_sel  mov ss,eax  mov esp,[esp_pointer]  mov ebx,message_6  call sys_routine_seg_sel:put_string  hlt\n\n用户程序代码：\n;===============================================================================SECTION header vstart=0         program_length   dd program_end          ;程序总长度#0x00              head_len         dd header_end           ;程序头部的长度#0x04         prgentry         dd start                ;程序入口#0x08         code_seg         dd section.code.start   ;代码段位置#0x0c         code_len         dd code_end             ;代码段长度#0x10         data_seg         dd section.data.start   ;数据段位置#0x14         data_len         dd data_end             ;数据段长度#0x18         stack_seg        dd section.stack.start  ;栈段位置#0x1c         stack_len        dd stack_end            ;栈段长度#0x20         ;-------------------------------------------------------------------------------         ;符号地址检索表         salt_items       dd (header_end-salt)/256 ;#0x24         salt:                                     ;#0x28         PrintString      db  &#x27;@PrintString&#x27;                     times 256-($-PrintString) db 0         TerminateProgram db  &#x27;@TerminateProgram&#x27;                     times 256-($-TerminateProgram) db 0         ReadDiskData     db  &#x27;@ReadDiskData&#x27;                     times 256-($-ReadDiskData) db 0header_end:;===============================================================================SECTION data vstart=0         buffer times 1024 db  0         ;缓冲区         message_1         db  0x0d,0x0a,0x0d,0x0a                           db  &#x27;**********User program is runing**********&#x27;                           db  0x0d,0x0a,0         message_2         db  &#x27;  Disk data:&#x27;,0x0d,0x0a,0data_end:;===============================================================================SECTION stack vstart=0        times 2048        db 0                    ;保留2KB的栈空间stack_end:;===============================================================================      [bits 32];===============================================================================SECTION code vstart=0start:        ; ds指向用户程序头部段         mov eax,ds         mov fs,eax         mov ss,[fs:stack_seg]         mov esp,stack_end         mov ds,[fs:data_seg]         mov ebx,message_1         call far [fs:PrintString]         mov eax,100                         ;逻辑扇区号100         mov ebx,buffer                      ;缓冲区偏移地址         call far [fs:ReadDiskData]          ;段间调用         mov ebx,message_2         call far [fs:PrintString]         mov ebx,buffer         call far [fs:PrintString]           ;too.         jmp far [fs:TerminateProgram]       ;将控制权返回到系统code_end:;===============================================================================SECTION trail;-------------------------------------------------------------------------------program_end:\n","tags":["win32 实模式到保护模式"]},{"title":"“汇编语言王爽（第4版）--实验13”","url":"/2025/11/03/%E2%80%9C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%8B%E7%88%BD%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89-%E5%AE%9E%E9%AA%8C13%E2%80%9D/","content":"该实验为编写并安装int 7ch中断例程，显示一个用0结束的字符串，并将中断例程安装到0:200处\n测试程序t1.asm用于触发7ch中断\nassume cs:codedata segment  db &quot;welcome to masm! &quot;,0data endscode segment  start: mov dh,10  mov dl,10  mov cl,2  mov ax,data  mov ds,ax  mov si,0  int 7ch  mov ax,4c00h  int 21hcode endsend start\n\n我们分析一下安装 int 7ch的主要步骤\n\n编写中断例程处理代码\n拷贝整个处理代码到0:200h\n覆盖7ch的地址，使之指向0:200h\n\n由此，可以得到一下代码\nassume cs:codecode segmentstart:  ;复制中断列程处理代码  mov ax,cs  mov ds,ax  mov si,offset do0  mov ax,0  mov es,ax  mov di,200h  mov cx,offset do0End - offset do0  cld  rep movsb  ;修改中断向量表  mov ax,0  mov es,ax  mov word ptr es:[7ch*4],200h  mov word ptr es:[7ch*4+2],0    mov ax, 4c00h ;复制完成后就退出  int 21h  ;实现输出显示在屏幕do0:   mov bl,cl  mov ax,0b800h  mov es,ax  mov di,10*160+36*10 ;屏幕中间显示  mov cx,17  s: mov al,[si]  ;循环从ds中提取数据写入缓冲区  mov ah,bl  mov es:[di],ax  inc si  add di,2  loop s  iretdo0end:  nop  code endsend start\n\n最终呈现效果：\n\n","tags":["learning-rookie"]}]