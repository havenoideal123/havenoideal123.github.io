<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="A1ex">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes ASAP (before DOMContentLoaded)
            (function() {
                const addBodyClass = () => {
                    const b = document.body;
                    if (!b) return false;
                    b.classList.add(theme + "-mode");
                    return true;
                };

                // Try immediately
                if (addBodyClass()) return;

                // Observe until body exists
                const mo = new MutationObserver(() => {
                    if (addBodyClass()) mo.disconnect();
                });
                mo.observe(document.documentElement, { childList: true, subtree: true });
            })();
        })();
    </script>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/11/07/利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查">
<meta property="og:url" content="http://example.com/2025/11/07/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E6%8F%90%E9%AB%98%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E6%9F%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/redefine-og.webp">
<meta property="article:published_time" content="2025-11-07T12:58:00.000Z">
<meta property="article:modified_time" content="2025-11-09T08:21:17.701Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="智能合约论文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查 | A1ex&#39;s blogs.
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en","path":"search.json"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Welcome to A1ex's security blogs.","subtitle":{"text":["Focus on smart contract audit and reverse engineering"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":50,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":"蝴蝶","artist":"陶喆","url":"http://t4z2rakny.hn-bkt.clouddn.com/mp3/%E8%9D%B4%E8%9D%B6.mp3","cover":"https://i.ytimg.com/vi/1wkI80-fpPw/hqdefault.jpg","lrc":null},{"name":"歌谣","artist":"李荣浩","url":"http://t4z2rakny.hn-bkt.clouddn.com/mp3/%E6%AD%8C%E8%B0%A3.mp3","cover":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ-pyZey8DKVpsr5qL5JDfPLOVcv6mDH3yVjQ&s","lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"FreeTalk":{"path":"/shuoshuo","icon":"fa-regular fa-chart-bar"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 8.1.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                A1ex&#39;s blogs.
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/shuoshuo"
                                        >
                                    <i class="fa-regular fa-chart-bar fa-fw"></i>
                                    FREETALK
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/shuoshuo"
                        >
                            <span>
                                FREETALK
                            </span>
                            
                                <i class="fa-regular fa-chart-bar fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">12</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/avatar.png">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">A1ex</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-11-07 20:58</span>
        <span class="mobile">2025-11-07 20:58</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-11-09 16:21:17</span>
            <span class="mobile">2025-11-09 16:21:17</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AE%BA%E6%96%87/">智能合约论文</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查"><a href="#利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查" class="headerlink" title="利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查"></a>利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查</h1><blockquote>
<p>智能合约（SCs）是区块链平台上自动执行的程序，正在通过自动化、无需信任的交易改变银行、医疗保健和供应链等行业。然而，它们固有的脆弱性导致了严重的财政和业务损失，大规模的攻击造成了重大的经济损失。机器学习（ML）已经成为一种很有前途的SC漏洞检测方法，但其有效性、适应性和通用性仍未得到充分探索。本文对当前以太坊SC漏洞和攻击进行了全面分类。它还调查了108种基于ml的检测方法，涵盖了传统模型和高级方法的结构化分类，如基于gnn的、基于llm的、对比学习、集成、混合、元学习和迁移学习技术。系统分析了这些方法的优势、局限性和实际挑战，特别关注检测阶段、分类问题、数据集特征、特征工程、性能评估、可泛化性、检测能力、模型老化以及伦理和隐私影响等因素。此外，对SC漏洞的现有数据集进行了审查和整合。通过整合这些见解，这项工作为构建安全、有弹性和值得信赖的SC生态系统提供了可操作的指导方针和基础。</p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>区块链技术最初于2008年推出，用于支持比特币加密货币，并已发展到支持广泛的应用。基于区块链的应用程序，如分散的医疗监控，可以在不依赖中央机构[6]的情况下实现交易各方之间的直接通信。第二代区块链主要以以太坊为代表，引入了智能合约（SCs），使现实世界的分散应用程序（DApps）能够跨越金融、预测市场和物联网（IoT）等领域。</p>
<p>虽然有这些优点，SC也面临重大安全挑战。开发人员的有限经验，加上编程语言的缺陷，造成了可利用的漏洞。根据SlowMist的数据，2024年，SC漏洞造成了99起事件和2.14亿美元的损失，截至2025年中期，加密货币总损失约为2.63亿美元。除了金融盗窃，SC法律还允许篡改攻击，例如虚假数据注入，威胁数据完整性。最近的几个高影响漏洞进一步说明了这些风险。</p>
<p>在2024年，Penpie在其市场创建过程中由于SC逻辑缺陷遭受了2735万美元的漏洞攻击，而Hedgey Finance则因输入验证漏洞损失了4470万美元。在2023年，值得注意的事件包括对Euler Finance的1.97亿美元攻击，对BonqDAO的1.2亿美元漏洞，以及由Vyper编译器漏洞引起的7350万美元的Curve Finance漏洞。这些事件凸显了当前安全措施中持续存在的漏洞。</p>
<p>SCs的安全性已成为一个突出的研究热点。传统的分析方法，如静态和形式分析、符号执行、混淆和代码合成，已被用于检测漏洞，但它们面临着关键的局限性，包括依赖源代码或局限于已知的漏洞模式。这些差距激发了人们对机器学习（ML）技术的兴趣，这种技术可以推广到固定模式之外，并提供自动化、可扩展和自适应的检测</p>
<p>然而，选择合适的机器学习范式仍然是一个挑战，因为模型在漏洞检测方面的有效性各不相同。传统的异常检测方法，如一类支持向量机（OCSVM）和隔离森林（IF），已经进行了探索，但往往表现不佳。这些模型依赖于统计异常值检测，无法捕获合约执行逻辑、控制流和合约之间的交互。与欺诈检测不同的是，欺诈检测中的异常通常是数字的，而SC威胁源于执行行为、操作码序列和合约相关性。因此，OCSVM和IF无法检测到诸如重入和交叉合约破坏等漏洞，这些漏洞涉及超出分布偏差的语义不一致</p>
<p>以太坊是DApps的龙头平台，得到了广泛采用、高交易量和活跃的开发者社区的支持。它也是SC安全研究中研究最多的，特别是基于ml的漏洞检测。虽然大多数基于ml的技术都是为以太坊sc开发的，但许多技术都有可能转移到以太坊虚拟机（EVM）兼容的区块链，如币安智能链（BSC）。相比之下，由于SC设计、共识机制和执行环境的差异，它们对非evm区块链（例如Solana）的适用性仍未得到充分探索。这些限制表明需要专门的基于ml的检测方法，并强调跨链SC安全是一个有前途的研究方向</p>
<p>先前的工作已经充分地研究了SC安全性，如表1所示。早期的研究根据生命周期阶段和攻击类型提出了SC漏洞的基本分类，并确定了更广泛的SC安全挑战。后来的研究通过分析真实世界的攻击、确定根本原因和评估缓解策略扩大了范围。SC安全性也通过软件开发生命周期的视角进行了研究，突出了合约设计和部署不同阶段的漏洞。其他工作评估了安全工具，比较了检测系统和入侵技术，同时总结了关键限制。为了支持威胁建模和自动化，已经提出了漏洞、漏洞利用和检测方法之间的结构化分类法和映射。最近的研究主要集中在基于机器学习的方法上，提供了对检测模型、数据集和评估框架的全面回顾</p>
<p>然而，在当前的SC脆弱性分析中，仍然存在一些关键的限制。有限的覆盖仍然是一个挑战，因为新的漏洞不断出现，需要定期进行全面的审查，以监测趋势和评估现有的安全措施。不一致的命名和缺乏标准化的SC漏洞标签阻碍了比较和清晰度。过时或不完整的分类法范围不同，需要整合。漏洞和攻击之间的映射不足仍然是一个问题，因为漏洞经常作为入口点，但是很少有评论系统地将它们与已知的漏洞联系起来。</p>
<p><a href=""><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.7-table1.jpg"
                      alt="App Platorm"
                ></a></p>
<p>在基于机器学习的检测领域，仍然存在一些挑战。机器学习解决方案没有按照它们检测到的漏洞进行一致的分类，限制了比较分析。现有的研究往往缺乏对研究差距的全面评估，这是指导未来努力所需要的。基本设计要求有效的基于ml的检测仍未确定。本文解决了这些挑战，并提出了以下关键贡献</p>
<ul>
<li>提供每个SC漏洞的详细描述，包括相关标签、DASP十大类别和相关攻击。引入了一种新的分类法来按来源对漏洞进行分类：安全问题、编程语言问题或开发问题。这种分类支持三个阶段的SC审核过程，每个阶段由一个专门的团队进行。</li>
<li>对2018年至2025年3月6日发布的108种基于ML的SC漏洞检测方法，按漏洞类型和ML模型进行了回顾和分类。一种新的分类法将传统方法与高级方法区分开来，后者分为七种类型：基于gnn的、基于llm的、对比学习、集成学习、混合学习、元学习和迁移学习。每项研究在分类类型、数据集、模型、验证策略和关键特征方面进行了系统的比较，为SC漏洞检测中的监督ML提供了当前的结构化参考。</li>
<li>确定开发有效的基于ml的检测方法的关键因素，并评估当前解决方案如何解决这些问题。概述了机器学习驱动SC漏洞检测的未来研究方向。</li>
</ul>
<p>本文其余部分的结构如下。第2节调查SC漏洞。第3节回顾了传统的基于ml的检测方法。第4节介绍了基于机器学习的高级方法。第5节讨论了基于ml的检测的设计考虑和未来的研究方向。第六部分对文章进行总结。</p>
<h2 id="2-智能合约漏洞分类"><a href="#2-智能合约漏洞分类" class="headerlink" title="2.智能合约漏洞分类"></a>2.智能合约漏洞分类</h2><p>文献中报道了几个SC漏洞，并由网络安全专家进行了分析。这些漏洞在几个方面有所不同，包括行为、严重级别和相关的攻击。本节简要讨论了用于对SC漏洞进行分类的因素，并介绍了文献中确定的漏洞</p>
<h3 id="2-1-智能合约漏洞类型"><a href="#2-1-智能合约漏洞类型" class="headerlink" title="2.1 智能合约漏洞类型"></a>2.1 智能合约漏洞类型</h3><p>文献中基于各种因素对SC漏洞进行了分类，如图1所示。一些研究根据其来源将SC漏洞分为三类。这种分类假设漏洞是由编程语言（例如，Solidity）、EVM功能或以太坊架构特征中的缺陷引起的。Qian等人提出了三层分类：solid代码层、EVM执行层和块依赖层。相比之下，Rameder等人根据共享特征将SC漏洞分为十类。</p>
<p><a href=""><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.8-fig.1.jpg"
                      alt="App Platorm"
                ></a></p>
<p>Zheng等人根据SC生命周期阶段将SC漏洞分为四组，其中每个阶段都有可能导致漏洞的不同挑战。其他研究人员采用了类似的方法，根据漏洞在以太坊架构层（应用程序、数据、共识和网络）中的位置对漏洞进行分类。大多数已知的SC漏洞发生在应用层。</p>
<p>nikoliki等人将漏洞按严重程度分为重大危害、慷慨和贪婪。这种分类强调了sc是否可以被任何用户破坏，是否可以将资金泄露给任意用户，是否可以无限期地锁定合同资金。Chen et al.将漏洞根据利用它们的攻击分为五组：未经授权的代码执行、DoS、不公平的收入、双重支出和私钥泄露。Gupta等人将漏洞分为逻辑漏洞和结构漏洞。逻辑漏洞源于开发过程中的业务逻辑错误，而结构漏洞源于技术设计规律。kabla将它们划分为功能、开发和安全级别，而Zhou等人提出了三种替代级别：攻击、程序和机制。</p>
<p>随着新的漏洞不断出现，开发预防性安全解决方案至关重要。了解每个漏洞的状态，无论是否完全解决，都是至关重要的。Kabla等人将SC漏洞分为三类：已解决、部分解决和仍然开放。该框架有助于研究人员和实践者优先考虑缓解工作。</p>
<p>网络安全从业者也为SC漏洞探索做出了贡献。2018年，NCC集团推出了去中心化应用程序安全项目（DASP） Top 10，确定了十个最关键的以太坊SC漏洞。不久之后，SC弱点分类（SWC）注册表发布，列出了在Solidity代码中发现的37个漏洞。DASP前10名仅发布一次，而SWC注册表自2020年以来更新有限。2022年，企业以太坊联盟（EEA）发布了EthTrust安全级别规范1，该规范定义了sc的安全要求。2023年，OWASP2社区发布了十大SC漏洞列表，该列表于2025年更新。</p>
<h3 id="2-2-漏洞映射"><a href="#2-2-漏洞映射" class="headerlink" title="2.2 漏洞映射"></a>2.2 漏洞映射</h3><p>研究SC漏洞并分析攻击行为对于制定有效的安全解决方案至关重要。与Zhou等人一致，我们发现没有标准参考文献全面涵盖所有报告的SC漏洞，而且许多引用使用了不同的名称。为了解决这个问题，我们在表2、3和4中编写了一个统一的参考，列出了每个漏洞、它的别名、它的DASP十大类别以及相关攻击的示例。</p>
<p>我们通过整合来自不同来源的漏洞和现实世界的漏洞，扩展了2.1节中讨论的先前的审查，包括同行评审的研究，SWC注册表，DASP Top10， CWE， SlowMist黑客数据库和rek .news。漏洞按根本原因系统分类，并在适用的情况下与一个或多个已记录的漏洞相关联。这种结构化的映射将理论上的漏洞类别与现实世界的攻击场景联系起来。补充资料的表S3提供了所有被引用攻击的详细信息。</p>
<p>我们观察到SC漏洞通常来自三个来源：安全问题、编程语言限制或开发缺陷。图2说明了这种分类，其目的是通过使团队能够专注于特定的问题类型来简化SC审计。</p>
<h2 id="3-传统智能合约漏洞检测的ML策略"><a href="#3-传统智能合约漏洞检测的ML策略" class="headerlink" title="3 传统智能合约漏洞检测的ML策略"></a>3 传统智能合约漏洞检测的ML策略</h2><h3 id="3-1-基于监督ml的检测模型"><a href="#3-1-基于监督ml的检测模型" class="headerlink" title="3.1 基于监督ml的检测模型"></a>3.1 基于监督ml的检测模型</h3><p>区分良性和脆弱的SCs是一个二元分类任务。S-ML被广泛应用于该任务，因为它能够从标记数据中学习，并且在结构化环境中表现出色。本节回顾了50种现有的基于s - ml的检测方法，并根据它们所处理的漏洞进行了分类。</p>
<h4 id="3-1-1-庞氏骗局"><a href="#3-1-1-庞氏骗局" class="headerlink" title="3.1.1 庞氏骗局"></a>3.1.1 庞氏骗局</h4><p>美国证券交易委员会（SEC）将庞氏骗局定义为用新参与者的资金向现有投资者支付回报的骗局。Charles Ponzi于1919年首次提出，其结构类似于金字塔：第一级的用户为第一级的用户提供资金，使早期参与者受益，而后期参与者则遭受损失。当募集放缓或出现大规模撤资时，此类计划就会崩溃。它们分为树形、链形、瀑布形和交接型。sc使自动化，增加投资者风险和威胁区块链安全。补充材料表S4总结了基于ml的庞氏骗局 SC检测方法。</p>
<p><a href="img"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.8-table-2.jpg"
                      alt="img"
                ></a></p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.8-table-3.jpg"
                      alt="App Platorm"
                ></a></p>
<p>研究强调了基于代码和基于交易的特征在检测庞氏SCs和零日攻击方面的有效性。XGB模型表明，庞氏检测在没有源代码的情况下是可行的，通过结合操作码和交易特征提高了性能。RF比XGB实现了更高的方差减少，并且可以在使用操作码特征部署后立即检测庞氏合约，但这两个模型都依赖于单一操作码频率，忽略了代码语义。基于代码的零日功能优于基于交易的功能（RF召回率：96% vs. 84%）。CatBoost和J48也达到了97%的召回率，具有排名第一的功能是基于代码.庞氏合约经常模仿交易特征中的正常行为，从而增加了错误分类的风险.</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.8-table-4.jpg"
                      alt="App Platorm"
                ></a></p>
<p>结合AST和基于交易的特征改进了DT、SVM和Multinomial NB (MNB)，每个都达到了94%的召回率，MNB总体上略好。来自源代码、操作码和交易数据的TF-IDF向量等混合特征增强了gb和ET的软投票集合，实现了89.67%的准确率和2.14%的FPR。在三个精心设计的数据集上进行的测试表明，删除非贡献行为特征可以提高性能，但召回率仍低于49%。具有纯代码和混合特征的基于射频的模型显示了交易数据的边际收益（召回率提高约2%）。ADASYN过采样与AdaBoost对3克操作码特征仍然产生适度的正类召回。</p>
<blockquote>
<p>关键的见解:</p>
<ul>
<li>集成学习不断提高检测性能。</li>
<li>操作码和字节码特征，结合有效的特征选择，对于准确和早期检测至关重要。</li>
<li>处理数据泄漏和类不平衡对于可靠的检测至关重要。</li>
</ul>
</blockquote>
<h4 id="3-1-2-钓鱼和欺诈"><a href="#3-1-2-钓鱼和欺诈" class="headerlink" title="3.1.2 钓鱼和欺诈"></a>3.1.2 钓鱼和欺诈</h4><p>传统的网络钓鱼攻击通过欺骗电子邮件或网站来获取敏感信息。在以太坊中，网络钓鱼利用平台的去中心化造成直接的经济损失，通常通过电子邮件、网站或社交媒体分发恶意地址。蜜蜂代币ICO骗局在25小时内被盗超过100万美元，证明了它们的快速影响。已经提出了几种基于ml的检测方法来解决这个问题，如补充材料表S5所示。</p>
<p>基于图的级联特征提取方法将事务建模为帐户关系，并提取多跳特征。通过过滤大多数类和应用基于lightgbm的双采样集成来解决类不平衡问题。虽然优于标准ml方法，但该模型的整体性能仍然有限。同样，在超过2000万个以太坊交易上训练的网络钓鱼检测模型通过过滤缓解了类不平衡，并使用了两种特征类型：基于账户（活动模式）和基于网络（结构）。AdaBoost的AUC最高，为92.76%，而SVM和KNN表现较差。用一个模拟异常节点的隐藏网络钓鱼框架进行测试，结果表明对规避技术的鲁棒性有限。</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.8-fig.2.jpg"
                      alt="App Platorm"
                ></a></p>
<p>Eth-PSD用于检测使用84,664个以太坊交易的网络钓鱼骗局。通过复制网络钓鱼样本来平衡数据集，并使用多种排序技术进行特征选择。60倍交叉验证的KNN准确率为98.11%，FPR为0.9%。输入、块高度和时间戳被认为是最有信息的特征。结合历史账户活动、网络架构特征和过采样改进的集成模型。然而，缺乏类分布报告降低了调查结果的可靠性。</p>
<p>在包含14个特征和4个标签的数据集上，RF的准确率为98.8%，FPR为0.05%，仅包含20%的异常事务。虽然主要目标是数据集构建，但结果表明集成模型在不平衡数据上表现良好。</p>
<p>在去中心化交易所（DEXs）的背景下，当开发商推出毫无价值的代币并在吸引投资者后撤回流动性时，就会发生“拉跌”。提出了一种XGB模型，通过分析Uniswap事件和令牌特征来检测此类诈骗。该模型针对的是池创建后的第一个24小时，因为大约93%的拉地毯事件发生在这个时间段内。早期检测实现了78.90%的召回率，尽管早期性能有所下降，但仍突出了机器学习预防诈骗的潜力。</p>
<blockquote>
<p>关键的见解:</p>
<ul>
<li>集成模型优于单个分类器，特别是当与有效的特征选择和不平衡处理相结合时。</li>
<li>处理数据不平衡并应用适当的验证技术，如过采样、特征过滤和双采样集成，可以显着提高分类精度。</li>
<li>区块链特定的功能对于检测至关重要，为网络钓鱼识别提供了强大的预测能力。</li>
</ul>
</blockquote>
<h4 id="3-1-3-非法账户"><a href="#3-1-3-非法账户" class="headerlink" title="3.1.3 非法账户"></a>3.1.3 非法账户</h4><p>许多恶意活动，如庞氏骗局、冒充和彩票骗局，都源于非法账户；早期发现对于减少欺诈至关重要。已经提出了几种ML方法，如补充材料的表S6所总结。对XGB模型中最重要特征的评估表明，帐户第一次和最后一次交易之间的时间是识别其合法性的最具影响力的因素。非法账户的平均使用天数为38.4天，而合法账户的平均使用天数为136.9天。</p>
<p>在使用相同平衡数据集的研究中，LGBM模型在检测欺诈性以太坊账户方面始终表现出卓越的性能。去除不相关的特征将模型的f1得分提高到高达99%，并且使用10倍交叉验证进一步提高了可靠性。然而，平衡的职业分布并不代表现实世界的情况。为了解决这个问题，在不平衡数据集上训练的检测模型也被探索。RF在历史账户数据上表现出优异的性能，但缺乏验证限制了其泛化性。</p>
<p>每种类型的以太坊账户都具有不同的特征和动态交易行为，使账户活动成为账户类型的有用指标。使用历史活动数据的多类分类提高了集成模型在平衡数据上的性能，尽管观察到覆盖的迹象。XGB在不平衡数据集上取得了最好的效果；然而，只有4371个账户的有限样本量降低了普遍性。</p>
<p>对自我网络微观子网特征的分析表明，非法账户之间存在差异。庞氏骗局账户的聚类系数低于网络钓鱼账户。结合子网和动态事务特性，提高了射频性能。然而，阶级分布严重倾斜，非法账户占88%，与现实情况相比，这是一个不现实的比例。</p>
<blockquote>
<p>关键的见解:</p>
<ul>
<li>基于增强的集成模型，特别是LGBM和XGB，是检测非法帐户的最有效方法之一</li>
<li>特征选择和数据集平衡是提高准确率的关键；删除不相关的特性和维护实际的类分布有助于防止重写。</li>
<li>小或不平衡的数据集限制了模型的泛化性，强调了反映真实世界非法账户分布的数据集的必要性。</li>
</ul>
</blockquote>
<h4 id="3-1-4-蜜罐合约"><a href="#3-1-4-蜜罐合约" class="headerlink" title="3.1.4 蜜罐合约"></a>3.1.4 蜜罐合约</h4><p>蜜罐合约是欺骗性的sc，似乎很容易引诱攻击者，从而通过隐藏的逻辑将他们困住。2019年，共有240名用户被此类攻击利用，获利超过9万美元。这些合约诱使攻击者窃取以太币，最终耗尽他们自己的资金。在某些情况下，如彩票合同，蜜罐也会损害良性用户。补充材料表S7总结了现有的检测方法。</p>
<p>由于蜜罐必须是可公开访问的才能吸引受害者，检测模型利用了基于代码的特征。LightGBM是在操作码n图特征上进行训练的，其中组合单图和双图产生了最好的结果，而添加三图只产生了边际改进。XGB混合使用了基于代码、基于事务和资金的特征。基于事务的特征单独表现最好，但当所有特征类型组合在一起时，准确性得到提高。关键特性包括合约创建者的存款频率、平均交易价值和代码长度。</p>
<p>以前的方法依赖于攻击后的特征（例如，余额，调用者）或仅在执行后可用的交易历史。相比之下，改进的XGB模型排除了这些特征，并使用了通过TF-IDF和word2vec提取的基于字节码的特征。使用word2vec和TF-IDF，模型的pr - auc分别为90.1%和89.2%；然而，word2vec的计算成本更高。主要特征包括存款频率和余额检查，通常存在于蜜罐合同中，以评估受害者的余额。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>基于增强的集成模型（如XGB和LGBM）显示出较高的检测精度。</li>
<li>特征选择至关重要；结合操作码和基于事务的特性可以提高性能。</li>
<li>早期检测受限于对执行后特性的依赖。基于字节码的特性很有前途，但计算成本很高。</li>
</ul>
</blockquote>
<h4 id="3-1-5-重入"><a href="#3-1-5-重入" class="headerlink" title="3.1.5 重入"></a>3.1.5 重入</h4><p>补充材料表S8中总结的研究解决了这种可能消耗合同资金的高影响脆弱性。动态检测框架Dynamit由两个组件组成：一个跟踪事务的监视器和一个使用行为特征和ML模型将它们分类为良性或恶意的检测器。在包含105个事务的平衡数据集上训练了6个分类器。RF实现了最高的精度（90%），当忽略平均调用堆栈深度特征时，其精度增加到94%。然而，小数据集限制了可泛化性。另一项研究提出了一个基于dl的框架，该框架将源代码分析与合同片段表示相结合，以提取语义相关的语句，并将合同分类为易受攻击或非易受攻击。这种方法有效地捕获了SC代码中的顺序和上下文模式，获得了88.26%的f1分数。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>RF优于单个分类器，但其有效性受到小数据集和中等精度的限制。</li>
<li>DL模型在SC代码中捕获时间模式，尽管它们目前的性能不足以用于实际部署。</li>
</ul>
</blockquote>
<h4 id="3-1-6-拒绝服务"><a href="#3-1-6-拒绝服务" class="headerlink" title="3.1.6 拒绝服务"></a>3.1.6 拒绝服务</h4><p>DoS是一种网络攻击，它破坏了对预期服务的访问。针对sc的各种类型的DoS攻击如表2和表4所示，相应的检测方案如补充资料表S10所示。</p>
<p>SCSCAN支持两种扫描模式：Single和Batch。它采用模式匹配来检测各种SC漏洞，而DoS则使用SVM模型单独识别。该框架识别漏洞，并按颜色编码的安全级别对契约进行排序。由于在不平衡的数据集上进行训练，除了DoS（92%）之外，它对所有测试漏洞都实现了100%的检测。</p>
<p>以太坊交易分析被用来检测2000个交易数据集上的低价DoS攻击，其中10%是恶意的。使用几种技术解决了类不平衡问题，其中过采样和SMOTE产生了最佳性能。DT达到了98%以上的召回率，而SVM表现最差，基于投票的模型没有达到预期。低价DoS攻击使以太坊平均交易等待时间增加了42%以上，这是一个关键的检测功能。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>集成模型，特别是RF，在检测DoS攻击方面优于其他分类器。</li>
<li>通过重采样技术（如过采样和SMOTE）解决数据不平衡问题，可以显著提高检测性能。</li>
<li>特征选择至关重要；交易延迟是DoS价格过低的一个有力指标，强调了行为分析的价值。</li>
</ul>
</blockquote>
<h4 id="3-1-7-多重漏洞"><a href="#3-1-7-多重漏洞" class="headerlink" title="3.1.7 多重漏洞"></a>3.1.7 多重漏洞</h4><p>几种多漏洞检测方法旨在提高实际场景下的效率和覆盖率，如补充材料表S9所示。SoliAudit[96]使用操作码特征检测DASP十大SC漏洞，并在两种配置下进行评估：(1)n-gram与TF-IDF和七个传统ML模型进行二元分类，(2)Word2Vec与CNN进行多标签检测。两种配置都达到了高达90%的精度，TF-IDF和LR表现最好。一项后续研究证实TF-IDF是CNN分类器中Word2Vec、FastText和BoW中最有效的表示。</p>
<p>xFuzz通过预测易受攻击的合约并使用模糊器扫描它们，将ML与模糊相结合，减少了搜索空间和执行时间。它检测了重入性、Tx-origin和delegatcall漏洞，而solidaudit则专注于算术和重入性。每个漏洞独立训练的基于ast的模型报告了不同的结果，平均f1得分为79%，尽管有限的数据和薄弱的验证降低了通用性。Eth2Vec应用基于nlp的EVM字节码相似性，对代码重写具有鲁棒性，但表现不佳，f1得分为57.5%。</p>
<p>ContractWard在早期工作的基础上，使用操作码双字符检测易受攻击的SCs。在49,502个SCs上使用One-vs-Rest策略测试了五个ML模型，六个漏洞标签的阈值为0.5。为了解决阶级不平衡问题，我们评估了两种抽样方法。使用SMOTETomek的XGB获得了最佳性能，在Macro-和micro - f1得分中超过96%，平均每SC检测时间为45秒，但无法检测到看不见的漏洞。一个相关的基于ast的模型通过比较solidfi -benchmark和SmartBugs中子节点的结构相似性，确定了8种漏洞类型。KNN的表现优于SGD，在所有指标上都达到90.10ś96.67%，超过了SmartCheck和Oyente。尽管结果很好，但有限的训练数据阻碍了推广和新漏洞的检测。</p>
<p>使用增强型遗传算法（EGA）的集成框架从AST、操作码、字节码和ABI视图中提取了240个特征，并选择了前80个。对111,897个sc进行了评估，它对11种漏洞类型进行了多类分类，尽管召回率仍然中等（41ś69%）。基于ast的轻量级CNN解决了物联网资源约束问题，实现了95.23%的重入召回率。sGuard[51]结合了基于ml的检测和基于规则的修复，使用签名和缓解功能针对五种漏洞类型。虽然性能有所不同，但它在未检查调用返回值、原点和重入性方面分别实现了96%、94%和90%的召回。</p>
<p>SC漏洞检测的最新进展强调混合和多模态DL框架，以提高准确性、鲁棒性和可扩展性。使用CodeBERT融合了操作码和源代码的特征，以实现高精度的异常检测。DeeSCVHunter将操作码序列和控制低图与BiLSTM和LSTM模型集成在一起，使用自关注来捕获语法和语义特征。COBRA采用字节码级方法，将基于gru的顺序建模与多尺度上下文感知模块相结合，以丰富特征表示。MODNN采用具有多目标学习的模块化深度神经网络，融合BERT嵌入的语义特征和操作码共现矩阵的结构模式，检测12种漏洞类型。</p>
<p>将字节码图像、契约图和专家定义的特征与VGG16、GRU、AutoInt和DCN集成在一起的统一框架的准确率超过96%。通过Word2Vec嵌入操作码并应用Bi-GRU、Transformer和注意力增强cnn的混合模型扩展了检测能力。使用TF-IDF和基于合成模式训练的MLP的轻量级解决方案实现了91.27%的f1得分。CodeNet通过无步进CNN将字节码作为图像处理，以保持操作码局部性。一个多模态框架结合了跨源、编译和字节码表示的白盒测试，利用BiLSTM、textCNN和RF实现84种检测策略，准确率高达99.71%。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>集成和深度学习模型在多漏洞检测方面优于传统分类器，尽管没有一个在所有类型中都表现出色。</li>
<li>特征提取强烈影响检测；TF-IDF和AST相似度等方法通常优于深度嵌入。</li>
<li>尽管最近的模型显示出对未知情况的改进的适应性，但跨漏洞类型的泛化仍然具有挑战性。</li>
<li>混合和多模式模型通过集成不同的特性来增强灵活性，但它们的成功依赖于架构和数据质量。</li>
</ul>
</blockquote>
<h3 id="3-2-基于无监督ml的检测模型"><a href="#3-2-基于无监督ml的检测模型" class="headerlink" title="3.2 基于无监督ml的检测模型"></a>3.2 基于无监督ml的检测模型</h3><p>无监督机器学习（U-ML）在没有标记数据的情况下发现模式和异常。在SC分析中，U-ML方法检测代码结构、执行行为和事务模式的变化。聚类组通过结构相似性收缩以发现异常值，而异常检测滞后于可能表明开采的不规则气体使用或函数调用。尽管有这些功能，由于假阳性率高、操作码敏感和效率低，U-ML很少被采用。研究表明，U-ML经常将良性行为错误地分类为恶意行为。例如，Lorenz等人发现IF和Local Outlier Factor难以区分非法交易和合法交易。同样，聚类也受到操作码多样性和编译器不一致性的影响，降低了可泛化性。</p>
<p>为了解决这些问题，Huang等人引入了一个基于图嵌入的字节码匹配框架。虽然对噪声和编译器不一致有效，但它仍然依赖于与已知模式的相似性，缺乏检测新漏洞的能力。更根本的是，U-ML技术不能可靠地捕获不表现为统计异常的上下文相关漏洞。由于缺乏语义理解，这些模型经常将无害的偏差错误地分类为威胁。</p>
<p>经验证据突出了U-ML的局限性。OC-Detector仅获得56%的f1得分，而用于重入检测的深度聚类方法[162]报告的得分低至7.1%ś9.5%，使得U-ML不适合精确的SC漏洞识别。计算需求带来了额外的挑战。虽然基本方法（如k-means）是有效的，但复杂模型（如深度聚类）可能超出S-ML的资源需求，阻碍了约束环境中的实时检测。此外，缺少标签会使验证变得复杂。尽管有这些缺点，当标记数据不可用时，U-ML仍然有希望识别未知或零日SC漏洞。未来的工作应该探索将U-ML的异常检测与S-ML的分类精度相结合的混合模型</p>
<h2 id="4-SC漏洞检测的高级ML方法"><a href="#4-SC漏洞检测的高级ML方法" class="headerlink" title="4 SC漏洞检测的高级ML方法"></a>4 SC漏洞检测的高级ML方法</h2><p>本节回顾了SC漏洞检测的高级ML技术，包括图神经网络（gnn），基于变压器的架构（例如，llm），元学习和混合方法。</p>
<h3 id="4-1-GNN-Based方法"><a href="#4-1-GNN-Based方法" class="headerlink" title="4.1 GNN-Based方法"></a>4.1 GNN-Based方法</h3><p>gnn是为图结构数据设计的，可以有效地捕获节点之间的复杂关系，使其非常适合SCs，可以用图编码控制低、数据依赖和函数调用来表示。补充材料的表S11总结了最近基于gnn的SC漏洞检测方法。</p>
<p>一些模型通过集成控制层和语义上下文来增强图级表示。ContractGNN引入了漏洞子图（Vulnerability Sub-Graphs, vsg）来隔离cfg的关键区域。SCVHunter采用异构GAT （HGAT）来突出语义上重要的节点，在47,587个sc中，在重入性和时间戳依赖上实现了93.72%和91.07%的准确率。DA-GNN结合了基于gru的语义注意和基于gat的结构注意，在17670个SCs上超过了gcn和gru。多标签GNN使用Sent2Vec嵌入和CFGs来检测单个SC内的多种漏洞类型。</p>
<p>其他模型融合了异构表示，以实现更深层次的语义理解。EtherGIS对六种漏洞类型的属性cfg应用TopK池。HG-Detector通过异构GNN集成了ast、CFGs和call graphs，实现了高达10.06%的精度提高和2.29%的f1得分增益。Cai等人通过将AST、CFG和PDG与程序切片和bi - ggnn结合起来扩展了这一点。</p>
<p>特定领域和混合gnn扩大了适用性。HARDEN将GCNs应用于操作码图，用于DeFi中的可重入性检测。Peculiar将数据低图与预训练的Transformer相结合。MANDO引入了bi - ggnn的多级嵌入，而MANDO- hgt则增加了变压器层和元关系建模。StateGuard使用ast衍生的图来检测DEX合约中的状态脱轨缺陷，在5,671个sc上获得了94.25%的f1得分。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>gnn通过对结构和语义关系建模，超越了静态和模糊方法，增强了SC漏洞检测。</li>
<li>基于注意力和异构gnn（例如，HG-Detector, SCVHunter）通过优先考虑语义上重要的节点和关键漏洞来提高准确性。</li>
<li>多标签gnn通过识别单个SC中的多种漏洞类型来扩展检测范围。</li>
</ul>
</blockquote>
<h3 id="4-2-LLM-方法"><a href="#4-2-LLM-方法" class="headerlink" title="4.2 LLM 方法"></a>4.2 LLM 方法</h3><p>llm具有高级的代码理解和推理能力，为Slither等基于规则的工具提供了数据驱动的替代方案。与静态启发式不同，llm利用上下文学习和模式识别来检测预定义签名之外的漏洞。补充材料表S12总结了基于llm的SC漏洞检测方法。</p>
<p>微调模型，如DistilBERT和BERT-ATT-BiLSTM显示出强大的性能。BERT-ATT-BiLSTM在随机平衡数据集上达到了86.67%的f1得分，而DistilBERT达到了97%的准确率。然而，小样本量（520 SCs）引起了对覆盖和有限泛化的担忧。</p>
<p>像PonziSleuth这样基于gpt -3.5 turbo构建的zero-shot模型，利用预训练的知识绕过了直线调谐，在检测庞氏骗局时达到了96.06%的平衡准确率。尽管如此，由于有限的任务适应，他们仍在与模糊的漏洞作斗争。多模态方法，如QuadraCode AI，结合源代码、字节码和操作码来增强鲁棒性，但增加了计算开销，限制了实时部署。</p>
<p>许多基于llm的方法依赖于合成数据集或小数据集，导致偏差和弱泛化。类不平衡进一步降低了对罕见漏洞的检测准确性。可解释性是另一个挑战，因为llm作为黑盒模型运行，不像具有可追溯输出的传统工具。效率也存在问题：像ft - codellam - 13b这样的大型模型只能达到34%的准确率，强调了规模和可部署性之间的权衡。此外，微调大模型是资源密集型的，限制了它们在SC审计中的实时使用。</p>
<p>将llm与符号执行相结合可以提高对新威胁的适应性。参数高效微调（PEFT）方法，包括LoRA和适配器调谐，旨在降低训练成本，同时保持性能，尽管它们在SC检测中的应用仍未得到充分探索。用真实世界契约和对抗性示例扩展训练数据集可以提高泛化能力。虽然llm在适应性和模式识别方面优于传统工具，但在数据集质量、可解释性和可扩展性方面仍然存在挑战。数据集多样性、混合模型和高效调优的进步是实现鲁棒性和可解释的基于llm的SC漏洞检测的关键。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>基于llm的检测提供了强大的模式识别，但由于数据集小，合成或不平衡而缺乏泛化。</li>
<li>集成传统的分析提高了准确性，但增加了复杂性，突出了对XAI和高效的优化方法的需求</li>
</ul>
</blockquote>
<h3 id="4-3-对比学习方法"><a href="#4-3-对比学习方法" class="headerlink" title="4.3 对比学习方法"></a>4.3 对比学习方法</h3><p>对比学习（CL）是一种突出的表征学习策略，它可以在不需要人工标记的情况下提取判别性和不变性特征。它通过优化正、负样本对的对比损失，在嵌入空间中将相似的实例投影得更近，而将不相似的实例投影得更远。在SC分析中，CL支持鲁棒特征学习，增强了漏洞检测能力。</p>
<p>最近的研究，总结在补充材料的表S13中，将CL应用于各种SC漏洞。ContraPonzi使用一种基于自监督graphsage的编码器，其正对由同一SC的多版本编译字节码形成，而负对则来自不同SC。这种增强捕获了不变语义，性能优于所有基线。</p>
<p>基于transformer的框架通过从漏洞标签构造对比对，将标签相同的合约分组为阳性，标签不同的合约分组为阴性，从而实现多类检测。该模型通过掩模语言建模（mask Language Modeling， MLM）集成了上下文增强，获得了94.52%的f1分数，优于基于规则和神经基线。ACAD侧重于使用图中心性引导的自适应CL进行重入和无限环路检测。结构增强，如边缘去除和特征掩蔽，选择性地应用以及提前停止，以提高稳定性。ACAD在Reentrancy上达到了93.87%的f1得分，但由于有限的标记数据，在infinite Loops上的表现较低。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>CL方法通过从图结构数据或源代码中学习判别特征来改进SC漏洞检测。</li>
<li>它们的性能取决于增强设计和自我监督策略，以减轻有限的标记数据。</li>
</ul>
</blockquote>
<h3 id="4-4-集成方法"><a href="#4-4-集成方法" class="headerlink" title="4.4 集成方法"></a>4.4 集成方法</h3><p>集成ML结合多个模型来提高预测精度、鲁棒性和泛化性，这些都是SC漏洞检测的关键。通过汇总来自不同分类器的输出，集成方法减少了方差和偏差，通常优于单个模型。补充材料表S14中总结了几种基于集成的方法，这些方法已显示出显著的性能增益。</p>
<p>SCVDIE-Ensemble集成了多种神经网络来提高准确性和鲁棒性。基于堆叠的集成与元学习器[105]将欺诈检测召回率提高到97.18%。PonziTect应用有序增强来解决类别不平衡问题，达到97%的召回率，而AI-SPSD通过整合公共数据来扩展庞氏检测，从而提高鲁棒性。</p>
<p>MuLCas采用带有阈值投票的多视图级联集成来组合来自多个分类器的预测，包括开发人员级别的特征。虽然这种方法改进了欺诈检测，但它强调了进一步优化召回的必要性。多模态决策融合方法集成了源代码、操作码和CFG特征，提高了性能，但其有效性因漏洞类型而异。软投票集成合并了在不同特征表示上训练的多个dnn的输出，减少了错误传播并提高了分类精度。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>集成模型通过组合不同的分类器和特征类型来提高鲁棒性，从而更有效地检测漏洞。</li>
<li>召回率和模型稳定性的可变性强调了控制集成体系结构和优化特征表示的必要性。</li>
</ul>
</blockquote>
<h3 id="4-5-混合方法"><a href="#4-5-混合方法" class="headerlink" title="4.5 混合方法"></a>4.5 混合方法</h3><p>混合ML模型结合了互补的学习技术来提高SC漏洞检测的准确性、鲁棒性和可扩展性。如补充材料表S15所述，最近的研究表明，这些模型在适应性和效率上都超过了独立的方法。</p>
<p>SCVD-SA将cnn与自关注相结合，优先考虑关键特征，增强了对多个漏洞的检测。同样，CNN-LSTM-Attention模型同时捕获了空间和时间模式，在重入性方面的f1得分为90.20%，召回率为90.47%。CGE将gnn与专家定义的控制和数据低模式相结合，在可重入性、时间戳依赖性和无限循环方面分别获得86.41%、87.75%和82.13%的f1得分。</p>
<p>ReVulDL使用GraphCodeBERT融合gnn和transformer进行重入检测，而SmartDT将基于注意力的深度学习与符号执行集成在一起，以增强可解释性和远程依赖建模。Liu等人利用增强了专家规则的gnn来分析基于图的SC特征。GRU- rf将GRU与rf相结合，平衡检测精度和效率，准确率达到98.47%。然而，注意层和循环层增加了计算复杂性，强调了在大规模部署中进一步优化的必要性。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>混合模型提高了检测精度，但需要进一步优化以实现可扩展性和高效部署。</li>
<li>混合体系结构有限的可解释性突出了对XAI和特征归因技术的需求，以确保透明性。</li>
</ul>
</blockquote>
<h3 id="4-6-元学习方法"><a href="#4-6-元学习方法" class="headerlink" title="4.6 元学习方法"></a>4.6 元学习方法</h3><p>元学习使模型能够用最少的标记数据在任务之间进行泛化，使其非常适合SC漏洞检测，其中注释的示例很少，并且经常出现新的威胁。He等人和Yang等人开发了基于模型不可知元学习（MAML）算法的框架，使用cnn在N-way K-shot设置中以EVM字节码作为输入。He等人在低数据场景下表现出优于传统模型的性能，而Yang等人报告了强有力的结果，总结在补充材料的表S16中。</p>
<p>一个关键的区别在于输入表示。SC学习者-元学习者框架（SCLMF）[158]将字节码转换为RGB图像，帧检测作为图像分类任务。它在Omniglot上达到了98.5%的准确率，但在sc特定的w潦草数据集上只有72.36%，这揭示了在捕获契约语义方面的局限性。相比之下，FSL-Detect从操作码构建cfg，提取TF-IDF特征，并将MAML与CNN集成。在2-way 5-shot设置下，它达到了93.98%的f1得分，提高了30%的召回率，突出了将结构和语义特征结合起来对于sc特定上下文的价值。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>元学习提高了对有限数据的适应性，但其计算开销突出了对更高效和可扩展策略的需求。</li>
<li>结果表明，表示选择强烈影响现实世界的性能，领域知情建模优于基于图像的方法</li>
</ul>
</blockquote>
<h3 id="4-7-迁移学习"><a href="#4-7-迁移学习" class="headerlink" title="4.7 迁移学习"></a>4.7 迁移学习</h3><p>由于数据不平衡、领域特定的特征和有限的标记实例，用于SC漏洞检测的传统ML模型通常难以推广到未见过或未充分代表的漏洞类型。迁移学习解决了这些挑战，利用知识从特征明确的漏洞，以提高对罕见或新颖类别的检测。正如补充材料表S17所总结的那样，目前的研究强调了它超越静态、单一任务模型的有效性。</p>
<p>Ye等人提出了一种领域自适应框架，该框架结合了用于合成数据生成的变分自编码器（VAE）和用于隔离共享和特定于领域的特征的领域分离网络（DSN）。他们的模型在检测由重入性转移的时间戳依赖漏洞方面达到了93.2%的准确率，比纯源基线高出25%。Naeem和Alali采用轻量级分类器利用句法和语义相似性进行交叉漏洞预测，报告的四个数据集的f1得分在73%到93%之间，大多数超过80%。</p>
<p>Qian等人引入了一种跨模态方法，其中只有字节码的学生模型使用源代码和字节码从教师模型中学习。Le等人通过定制的蒸馏器模型（与MLP和LSTM层进行线性调优）应用迁移学习，使用深度上下文化代码表示来检测可重入漏洞。</p>
<blockquote>
<p>关键的见解</p>
<ul>
<li>迁移学习通过域不变特征和跨类型语法相似性增强了对未见或未充分代表的SC漏洞的泛化。</li>
<li>当共享特征表示可用时，DSN等轻量级模型可以有效地检测漏洞，而无需重新训练。</li>
</ul>
</blockquote>
<h3 id="4-8-比较分析"><a href="#4-8-比较分析" class="headerlink" title="4.8 比较分析"></a>4.8 比较分析</h3><p>传统的机器学习模型，特别是集成模型，对于SC漏洞检测仍然非常有效，一些研究报告的准确率和召回率超过95%。RF在非法账户检测方面达到98%的召回率和97.5%的准确率，而LGBM在类似任务中这两个指标的准确率为99%。即使是简单的KNN模型也能达到98%的召回率。基于集成的方法通常对单个漏洞检测最有效，但由于特征表示的限制，在多漏洞场景下性能下降。</p>
<p>在单漏洞和多漏洞检测方面，先进的集成方法继续优于许多现代方法，一些研究报告了95ś98%的精度和96ś97.26%的召回率。混合架构也表现强劲，超越了传统的ML和gnn（例如，GRU RF实现了97.34ś98.3%召回率）。最近的研究越来越多地利用LLM，如GPT-4和基于codeberta的框架，其中9调优模型的召回率达到97.37%。然而，由于每类报告和异构数据集，多漏洞任务的性能比较仍然具有挑战性。</p>
<p>对比学习、元学习和迁移学习等新兴学习范式通过增强适应性和泛化能力显示出强大的潜力。对比学习取得了竞争性的结果（例如，95.36%的召回率），而元学习（基于mml的）在少量射击设置下表现优异，召回率高达91.56%[64]。迁移学习进一步提高了跨数据集泛化，召回率达到91.09%。尽管探索较少，但这些方法是对现有ML框架的补充。</p>
<p>不同模型类型的训练和检测时间差异很大。在回顾的传统模型中，只有RF和KNN报告较低的训练时间，只需要0.01ś0.06 s，而更复杂的模型，如EGA，需要47ś53 s来检测。cnn报道0.13ś0.15的检测次数为s。基于gnn的方法通常涉及更高的检测开销，例如，SCVHunter报告的平均检测时间为0.66 s，而ContractGNN达到2.19 s。同样，基于llm的技术表现出更高的检测时间，PonziSleuth需要5.52秒，基于gpt -3的VulnHunter需要23秒。</p>
<p>考虑到它们较低的训练开销，RF（一种集成方法）和KNN（一种简单的基于实例的模型）都适合快速部署。然而，它们的实时适用性取决于推理延迟和系统约束等因素，而这些因素在所回顾的研究中没有得到检验。相比之下，gnn和llm显示更高的计算成本，使它们更适合在线分析。性能特征的总结在补充材料中提供（表S4śS17），并在第5节中进行进一步讨论。</p>
<h2 id="5-讨论以及未来的研究方向"><a href="#5-讨论以及未来的研究方向" class="headerlink" title="5 讨论以及未来的研究方向"></a>5 讨论以及未来的研究方向</h2><p>现有的基于ml的SC漏洞检测方法存在一些特点和局限性。图3概述了影响解决方案设计的关键因素，以及相关的需求。本节讨论每个因素，评估针对这些要求的当前方法，并强调未来的研究方向。</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.3.jpg"
                      alt="App Platorm"
                ></a></p>
<h3 id="5-1-检测阶段方法"><a href="#5-1-检测阶段方法" class="headerlink" title="5.1 检测阶段方法"></a>5.1 检测阶段方法</h3><p>SC漏洞通常通过三种主要方法检测：部署前、部署后和零日检测。预部署方法，如在部署前分析SC源代码，以识别漏洞并确保安全发布。部署后的方法，例如，监视事务行为以检测异常。</p>
<p>一些方法，例如，将静态代码特征与事务数据结合起来以提高准确性，尽管这些方法需要部署sc和足够的事务历史记录。零日检测方法，例如，旨在在部署后立即识别恶意sc，在任何交易之前，使其有效应对庞氏骗局和地毯拉等威胁。</p>
<p>尽管部署前检测是必要的，但某些漏洞仅在执行过程中出现，而有些合约是带有恶意目的设计的。因此，全面的安全解决方案应该集成所有三个检测阶段：在部署前验证sc，在执行期间监视它们，以及在部署后立即检测零日威胁</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>检查集成的基于ml的方法，以快速检测和预防SC漏洞。</li>
<li>探索不同区块链环境中SC检测工具的有效集成点。</li>
<li>优化基于ml的检测技术，在资源限制下实现可扩展、实时和链上执行。</li>
</ul>
</blockquote>
<h3 id="5-2-分类问题"><a href="#5-2-分类问题" class="headerlink" title="5.2 分类问题"></a>5.2 分类问题</h3><p>SCs通常包含多个漏洞，使得检测本质上是一个多标签分类问题。然而，一些基于ml的模型专注于单一的漏洞类型，限制了现实世界的适用性。</p>
<p>在文献中，SC漏洞检测被视为具有多标签类的二值分类或作为一个多类问题。Momeni等人经验表明SC漏洞是独立的，证明需要为每个漏洞训练单独的二元分类器，这一方法与网络威胁检测实践一致。确定具体的脆弱性类型对于指导有针对性的缓解战略仍然至关重要。</p>
<p>S-ML方法由于其结构化分类能力和对标记数据集的高准确性而获得了比U-ML方法更多的关注。然而，这种对标记数据的依赖限制了对零日漏洞和不断发展的SC结构的适应性。此外，随着新威胁的出现，为每个漏洞训练单独的模型会带来可扩展性方面的挑战</p>
<p>相比之下，U-ML方法，如聚类和异常检测，显示出检测未知漏洞的潜力。然而，他们对统计偏差的依赖，而不是执行意识分析，往往导致高假阳性。此外，对操作码变化和编译器不一致的敏感性降低了它们在不同SC实现中的通用性</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>根据网络威胁检测需求，开发能够检测各种SC漏洞的基于ml的方法。</li>
<li>检查U-ML技术在零日SC漏洞检测方面的潜力，重点是执行感知模型，以减少误报并提高准确性。</li>
<li>设计S-ML和U-ML相结合的混合模型，增强适应性和精度。利用图学习、变换和对比学习可以改进特征表示，用于新的威胁检测。</li>
</ul>
</blockquote>
<h3 id="5-3-数据集的特点"><a href="#5-3-数据集的特点" class="headerlink" title="5.3 数据集的特点"></a>5.3 数据集的特点</h3><p>数据集的质量、多样性和结构严重影响基于ml的SC漏洞检测的性能、鲁棒性和泛化性。如补充资料总结表S18所示，现有数据集可分为四种类型：(1)原始构建的，为特定任务从零开始构建，相关性高但资源密集；(2)合并，通过组合多个源来提高多样性，通常需要预处理来解决不一致性；(3)扩展，通过在现有数据集上添加特征或样本来提高准确性；(4)用于基准测试的其他数据集的复制、精确副本，但通常已经过时或缺乏多样性。</p>
<p>在回顾的研究中，Etherscan explorer是最常用的数据源，其次是BigQuery、CryptoscamDB和dapp相关平台。所收集数据的可靠性取决于这些来源的准确性、多样性和及时性。一些被检查的数据集已经过时，缺乏反映SC漏洞和区块链技术快速发展所需的定期更新。</p>
<p>此外，数据集在标签多样性、样本量和类别分布方面差异很大。许多模型样本不足或类失衡严重，限制了模型的泛化和训练的有效性。例如，970,898份合同中有34,200份是脆弱的（约占4%），突出了不平衡的严重性。</p>
<p>然而，在反映现实世界条件的最佳类别比例上没有达成共识，导致不同研究的方法不一致。</p>
<p>类别不平衡带来了重大挑战。机器学习模型往往偏向于大多数类别，导致对脆弱的SCs的召回率很低。像LR和SVM这样的传统算法很难从罕见的情况中学习，因为它们的损失函数由多数类数据主导。因此，在不平衡的数据集上训练的模型不能泛化，往往在错过关键漏洞的情况下获得误导性的高准确性。</p>
<p>为了解决这个问题，我们研究了三个主要策略，如图4所示。数据驱动技术包括过采样、欠采样和混合采样。过采样提高了少数族裔的代表性，但可能会引入噪音和覆盖。欠采样减少了多数类样本以减少偏差，但有丢弃有价值信息的风险。混合采样平衡两者，但需要仔细调优以避免数据丢失或冗余</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.4.jpg"
                      alt="App Platorm"
                ></a></p>
<p>算法驱动的方法修改了学习过程本身。其中包括类权重调整和集成学习，以减轻偏差并提高鲁棒性。虽然这些方法保留了原始数据，但它们需要仔细地进行超参数调优，如果配置不当，可能会出现覆盖或遗漏的问题。混合方法结合了这两种策略，以利用它们的优势，同时减轻个体的缺陷。然而，在选择最佳重采样比和调谐参数方面仍然存在挑战</p>
<p>尽管区块链数据的可访问性，为SC漏洞检测策划的公共数据集仍然有限。许多条目过时，缺乏多样性，标签不完整，或者需要大量预处理的原始格式。这种稀缺性源于专有限制、隐私风险、高数据准备成本以及精确SC注释的技术复杂性等因素。这些挑战凸显了协作开发和维护高质量开放获取数据集的必要性</p>
<blockquote>
<p>潜在研究方向</p>
<ul>
<li>系统分析SC漏洞，攻击模式和关键属性，以构建高质量的数据集。从业者的输入对于控制定义和确保与现实世界的威胁保持一致至关重要。</li>
<li>为SC数据集的构建、维护和扩展开发自动化的自适应框架，以确保及时更新、语义完整性和有效的模型训练。</li>
<li>通过抗噪声重采样、混合采样和成本敏感学习增强不平衡处理，同时避免覆盖和保持数据多样性</li>
<li>通过改进表征、重采样和损失函数来推进多标签学习，以捕获脆弱性之间的关系并解决类别不平衡问题</li>
</ul>
</blockquote>
<h3 id="5-4-功能类型"><a href="#5-4-功能类型" class="headerlink" title="5.4 功能类型"></a>5.4 功能类型</h3><p>如图5所示，ML模型使用了几种特征类型来检测SC漏洞和相关攻击。这些特性可以分为基于代码的、基于事务的或混合的。</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.5.jpg"
                      alt="App Platorm"
                ></a></p>
<p>基于代码的特性是研究最广泛的。基于令牌的特性（补充材料的图S8）提供了丰富的语法和语义信息，但需要源代码，而源代码通常是不可用的。代码重用也会导致跨sc的字节码重复，增加数据集冗余。</p>
<p>基于操作码的特征（补充材料的图S9）是从字节码中提取出来的，更适合于现实世界的场景，尽管它们的可解释性较差。混合功能(图S10的补充材料)集成表示（例如，令牌操作码）以捕获更丰富的语义，但增加了复杂性。附加的特征类型（补充材料的图S11）捕获了可选的SC行为</p>
<p>基于事务的特性（补充材料的图S12）可以是静态的，也可以是动态的。静态特征捕获交易特征（例如，gas使用），而动态特征反映行为方面（例如，交易量），并可能包括基于图形的特征，将帐户交互建模为链接。需要进一步的研究来评估图特征和交叉类型组合的效用。</p>
<p>基于代码的特性可以在部署前或部署后提取，从而实现早期检测，而基于事务的特性需要实时SC活动。合并代码和事务数据的混合方法通常可以提高性能，如补充材料的图S13所示。</p>
<p>不同的特性类型可以检测到相同的漏洞。例如，结合账户和图形特征来检测庞氏骗局，而仅依赖于图形特征。Rizzo等人的基准测试证实了输入类型（如源、操作码、AST、CFG）显著影响检测性能。没有哪一种功能类型总是优于其他类型。多模态输入，特别是在集成模型中，通常会产生更好的结果。由于实验设置的异质性，确定一个普遍最优的特征类型仍然是不可行的。</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>由于实验设置的异质性，现有研究对不同特征类型的有效性提供了不确定的证据。需要进行全面的实证评估，以确定检测各种SC漏洞和相关攻击的最佳特征。</li>
</ul>
</blockquote>
<h3 id="5-5-特征工程"><a href="#5-5-特征工程" class="headerlink" title="5.5 特征工程"></a>5.5 特征工程</h3><p>机器学习模型需要预处理数据来进行有效的训练。特征工程是选择、提取和转换相关数据属性的过程，在提高模型精度方面起着至关重要的作用。技术的选择取决于问题的性质。</p>
<p>如图6所示，许多研究依赖于基于nlp的方法从原始SC数据中提取特征。一些人采用手工方法，而另一些人，如Chen等人，则提出自定义提取技术。Pragasam等人利用BigQuery平台进行自动特征采集。</p>
<p>尽管消除不相关的特征可以显著提高模型性能，但图7显示，特征选择通常没有得到充分的研究。有限的选择技术的采用意味着SC漏洞检测的最佳方法仍然没有解决。</p>
<p>在回顾的研究中确定了四种数据标记策略（参见图8）：(1)利用以前的提示，(2)使用SC分析工具，(3)从公共存储库检索标记的合同，以及(4)手动注释。考虑到SC漏洞不断演变的本质和攻击者使用的混淆策略，标记方法必须捕捉每个漏洞的最新模式</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>研究各种特征提取和选择方法对SC漏洞检测中ML模型性能的影响，重点是确定基于投票的选择策略等最佳技术。</li>
<li>通过鼓励专家主导对部署的SC和漏洞报告的分析，解决标记SC漏洞数据集的短缺问题。建立一个共享的、最新的公共存储库对于支持有效的基于ml的SC漏洞检测至关重要。</li>
</ul>
</blockquote>
<h3 id="5-6-绩效评估"><a href="#5-6-绩效评估" class="headerlink" title="5.6 绩效评估"></a>5.6 绩效评估</h3><p>准确性、精密度、召回率、f1分数等评价指标被广泛应用于SC漏洞检测研究中。然而，这些指标经常在不平衡的数据集上产生误导性的结果。准确性忽略了类的分布。f1分数忽略了真正的否定，并且相对于类别标签是不对称的。马修斯相关系数（MCC）通过结合混淆矩阵的所有四个元素来解决这些问题，为平衡和不平衡数据集提供公正的评估。MCC只有在正确预测正面和负面类别时才会获得高分，而不管它们的比例如何。</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.6.jpg"
                      alt="App Platorm"
                ></a></p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.7.jpg"
                      alt="App Platorm"
                ></a></p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.8.jpg"
                      alt="App Platorm"
                ></a></p>
<p>一些研究，使用SC漏洞分析工具作为评估ML模型的基线。然而，这些工具无法检测所有类型的SC漏洞，限制了它们进行全面性能比较的有效性。</p>
<p>除了分类度量之外，评估训练时间、推理延迟和模型复杂性对于评估部署可行性也是必不可少的。在在线环境中，训练时间决定了模型适应新威胁的速度。在实时场景中，低推理延迟对于部署前检查和持续监控至关重要。模型复杂性不仅影响计算开销，还影响可解释性和部署的便利性，特别是在受约束或分散的环境中。尽管这些指标很重要，但它们经常被忽视，这限制了在现实条件下评估模型有效性的能力。</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>为基于ml的SC漏洞检测采用稳健的验证策略，结合不同的度量、统计显著性测试和可视化分析工具（如箱线图）</li>
<li>评估训练时间，推理延迟和模型复杂性，以确保在线分析和实时部署的适用性。</li>
</ul>
</blockquote>
<h3 id="5-7-概括性"><a href="#5-7-概括性" class="headerlink" title="5.7 概括性"></a>5.7 概括性</h3><p>模型验证对于确保可靠和可复制的性能结果至关重要。大多数研究采用保留方法（将数据分为训练和测试），由于样本差异，可能产生不一致的结果，从而限制了通用性。虽然Zheng等人认为交叉验证不适合具有时间依赖性的数据，仍然需要健壮的验证策略。一些研究只在训练集中进行交叉验证。考虑到大多数SC数据集的规模较小，保持训练和测试数据之间的平衡分布是至关重要的。</p>
<p>标记SC漏洞数据集的稀缺性仍然是一个主要挑战。这些数据集通常很小，不平衡，并且特定于领域，限制了对看不见的漏洞，契约结构，编译器版本和不断发展的语法的推广。迁移学习提供了一个很有前途的解决方案，它使模型能够跨契约类型进行泛化，尽管仍需要进一步研究在线调整和领域适应策略。</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>通过跨越多个区块链平台的多种真实数据集，提高基于ml的漏洞检测的泛化和适应性。强调交叉验证、特征对齐和对抗性训练，以管理领域转移、不断发展的SC标准和编译器变化。</li>
<li>通过迁移、在线和自监督学习提高学习效率和鲁棒性。利用相关的漏洞类别并启用增量更新来解决未见的或混淆的威胁，而无需频繁的再培训。</li>
<li>使用集成表示训练的多模态和基于llm的模型提高检测精度。采用数据融合和对比调优来更好地捕获微妙的漏洞模式。</li>
</ul>
</blockquote>
<h3 id="5-8-检测能力"><a href="#5-8-检测能力" class="headerlink" title="5.8 检测能力"></a>5.8 检测能力</h3><p>迄今为止，没有一种基于ml的方法可以检测到所有SC漏洞；大多数方法都针对特定类型。例如，SoliAudit专注于算术和重入问题，而SCScan使用部分基于ml的架构针对DoS漏洞。这突出了传统机器学习技术的局限性，它依赖于手工制作的特征，并与看不见的攻击向量作斗争。</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.9.jpg"
                      alt="App Platorm"
                ></a></p>
<p>最近的进展结合了结构和语义分析来提高覆盖率。gnn通过对代码依赖关系进行建模来增强结构推理，而转换器和llm则捕获上下文和语言级语义。元学习和对比学习促进了低数据场景下的泛化，从而能够检测新出现的漏洞。然而，在可解释性、可伸缩性和部署方面仍然存在挑战。</p>
<p>图9和图10所示的对所回顾研究的比较分析表明，DT、SVM和KNN经常被应用，但套袋（RF）和提升（XGB）集成通常可以获得更好的性能，特别是在检测非法账户和庞氏骗局方面。LGBM虽然不太常见，但表现良好，这表明模型选择通常更多是由熟悉程度而不是经验证据驱动的。由于其较高的复杂度和计算成本，堆栈和投票集成很少被采用。DL模型、LSTM、Bi-LSTM和GCN由于数据集小、SC语义复杂和缺乏特定领域的架构设计而未得到充分利用。</p>
<p>对于零日漏洞，gnn检测cfg、DFGs和相关图中的结构异常，但依赖于准确的图提取，语义推理有限，使得它们对微妙的攻击不太有效。llm泛化了看不见的模式，但在没有特定于领域的调优的情况下，很难处理原始字节码和运行时数据。集成方法结合多个机器学习模型来提高泛化和鲁棒性，但在面对新行为时往往会增加计算量和误报。</p>
<p>迁移学习能够从预先训练的模型中进行适应，但会受到领域转移的影响。对比学习有助于异常检测，但需要精心配对，并且可解释性较差。元学习支持以最少的数据快速适应新威胁，尽管其有效性取决于预训练的多样性。结合gnn、llm和元学习为全面的零日检测提供了一个有前途的方向。</p>
<p><a target="_blank" rel="noopener" href="https://file+.vscode-resource.vscode-cdn.net/Users/a1ex/Documents/MyBlog/source/_posts/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/blogImage/11.9-fig.10.jpg"
                      alt="App Platorm"
                ></a></p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>开发基于ml的模型，能够检测各种SC漏洞，包括零日漏洞，并通过定期更新和评估来确保在不断发展的分散环境中的有效性。</li>
<li>通过探索增强、套袋和自适应堆叠来推进集成方法，同时研究基础学习器的上下文感知选择和评估数据集之间的模型一致性</li>
<li>通过多模态学习（例如，源代码、字节码、跟踪、审计报告）和对抗性训练增强基于llm的检测，以提高对混淆和逃避的鲁棒性。</li>
<li>通过模型压缩和架构优化来解决效率挑战，从而改进混合模型。</li>
<li>探索元学习以实现快速泛化，并提高可解释性，以支持实际部署。</li>
</ul>
</blockquote>
<h3 id="5-9-模型老化"><a href="#5-9-模型老化" class="headerlink" title="5.9 模型老化"></a>5.9 模型老化</h3><p>恶意软件的性质不断演变其防止检测的方法。因此，必须定期评估基于机器学习的漏洞检测系统；它们必须能够检测到任何新的漏洞模式。在基于ml的检测模型中应该解决的主要问题之一是模型老化&#x2F;漂移[172]。鉴于恶意软件的快速发展，大多数被分析的方法可能会随着时间的推移而急剧退化。目前基于ml的SC漏洞检测方法尚未研究漂移检测。</p>
<blockquote>
<p>潜在的研究方向</p>
<ul>
<li>不断发展的SC漏洞需要主动的模型漂移管理来保持检测的可靠性。研究应该探索漂移检测算法，评估漂移的严重程度、时间和受影响的特征区。</li>
<li>在基于llm的检测中解决模型老化问题需要持续的学习策略来保持先前的性能。PEFT方法和自适应快速调优可以降低再培训成本，提高对新出现威胁的响应能力。</li>
</ul>
</blockquote>
<h3 id="5-10-机器学习模型的能力和效率"><a href="#5-10-机器学习模型的能力和效率" class="headerlink" title="5.10 机器学习模型的能力和效率"></a>5.10 机器学习模型的能力和效率</h3><p>ML模型检测SC漏洞的能力取决于它们处理和表示代码特征的方式。单个模型（例如，LR， SVM）是高效的，并且非常适合于检测简单的，基于模式的漏洞，如算术溢出和时间戳依赖，这通常涉及显式的操作码模式或数值阈值。</p>
<p>集成方法（例如RF， XGB）结合多个学习器来提高性能，使它们对中等复杂的漏洞（如访问控制违规和未检查的低级调用）有效，这些漏洞涉及更微妙的特征交互。gnn对于捕获sc中的结构关系特别有效，有助于检测依赖于调用序列和内部契约行为的可重入性和授权逻辑律。</p>
<p>基于转换器的模型擅长通过对SC代码的语义和句法结构建模来识别高级逻辑漏洞。混合方法，如将gnn与集成模型相结合，提供了更广泛的覆盖范围，但随之而来的是计算复杂性的增加和可解释性的降低。</p>
<p>除了检测精度外，计算效率对于实时或链上使用至关重要。如补充材料表20所示，传统模型需要最少的训练和推理资源，因此适合在受限环境中部署。集成方法虽然资源更密集，但提供了折衷方案：套袋模型支持并行推理，而增强方法以顺序训练和较慢推理为代价获得更高的准确性。gnn和变压器擅长结构和语义推理，但需要大量的计算资源，限制了它们在在线或审计阶段分析中的使用。由于多层推理管道，混合模型进一步增加了开销。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>SC安全仍然是一个重大挑战，许多灾难性的攻击造成了重大的经济损失。新的SC漏洞的不断出现强调了对能够识别零日攻击的强大检测方法的需求。mlmodel在检测SC漏洞和相关攻击方面显示出越来越大的希望。在本文中，我们进行了一项最新的调查，突出了ml模型用于SC漏洞检测的潜力。我们提供了一个对已知漏洞进行定义和分类的综合参考，并根据漏洞的来源介绍了一种新的分类法：安全问题、编程语言问题和开发问题。我们对每个漏洞的传统和先进的基于ml的检测方法进行了回顾和分类，并对实证研究的关键方面进行了比较和总结。我们还概述了在开发基于ml的检测方法时需要考虑的重要因素，并确定了有希望的未来研究方向。本文可以作为对推进ml驱动的SC漏洞检测感兴趣的研究人员和实践者的详细参考</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查</li>
        <li><strong>Author:</strong> A1ex</li>
        <li><strong>Created at
                :</strong> 2025-11-07 20:58:00</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-11-09 16:21:17
            </li>
        
        <li>
            <strong>Link:</strong> https://havenoideal123.github.io/2025/11/07/利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%AE%BA%E6%96%87/">#智能合约论文</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%BB%BC%E8%BF%B0/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">区块链安全大语言模型：系统文件综述</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/11/06/%E5%B0%8F%E5%9E%8B%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F-md/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">小型内核加载程序.md</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'havenoideal123/giscus_storage',
                'data-repo-id': 'R_kgDOQMJJcA',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDOQMJJcM4CxQZl',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'not-lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E6%8F%90%E9%AB%98%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%92%8C%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E6%9F%A5"><span class="nav-text">利用机器学习模型提高智能合约安全性：漏洞和检测方法的调查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E5%88%86%E7%B1%BB"><span class="nav-text">2.智能合约漏洞分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.1 智能合约漏洞类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%BC%8F%E6%B4%9E%E6%98%A0%E5%B0%84"><span class="nav-text">2.2 漏洞映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BC%A0%E7%BB%9F%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E7%9A%84ML%E7%AD%96%E7%95%A5"><span class="nav-text">3 传统智能合约漏洞检测的ML策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9F%BA%E4%BA%8E%E7%9B%91%E7%9D%A3ml%E7%9A%84%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.1 基于监督ml的检测模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%9F%BA%E4%BA%8E%E6%97%A0%E7%9B%91%E7%9D%A3ml%E7%9A%84%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.2 基于无监督ml的检测模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-SC%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E7%9A%84%E9%AB%98%E7%BA%A7ML%E6%96%B9%E6%B3%95"><span class="nav-text">4 SC漏洞检测的高级ML方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-GNN-Based%E6%96%B9%E6%B3%95"><span class="nav-text">4.1 GNN-Based方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-LLM-%E6%96%B9%E6%B3%95"><span class="nav-text">4.2 LLM 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95"><span class="nav-text">4.3 对比学习方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95"><span class="nav-text">4.4 集成方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95"><span class="nav-text">4.5 混合方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E5%85%83%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95"><span class="nav-text">4.6 元学习方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0"><span class="nav-text">4.7 迁移学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90"><span class="nav-text">4.8 比较分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%AE%A8%E8%AE%BA%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91"><span class="nav-text">5 讨论以及未来的研究方向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%A3%80%E6%B5%8B%E9%98%B6%E6%AE%B5%E6%96%B9%E6%B3%95"><span class="nav-text">5.1 检测阶段方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-text">5.2 分类问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">5.3 数据集的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%8A%9F%E8%83%BD%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.4 功能类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B"><span class="nav-text">5.5 特征工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E7%BB%A9%E6%95%88%E8%AF%84%E4%BC%B0"><span class="nav-text">5.6 绩效评估</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-%E6%A6%82%E6%8B%AC%E6%80%A7"><span class="nav-text">5.7 概括性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B"><span class="nav-text">5.8 检测能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-%E6%A8%A1%E5%9E%8B%E8%80%81%E5%8C%96"><span class="nav-text">5.9 模型老化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%83%BD%E5%8A%9B%E5%92%8C%E6%95%88%E7%8E%87"><span class="nav-text">5.10 机器学习模型的能力和效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%80%BB%E7%BB%93"><span class="nav-text">6 总结</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">A1ex</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        12 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>